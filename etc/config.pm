# $Header$	

package RT;

# {{{ Base Configuration

# rtnampe the string that RT will look for in mail messages to
# figure out what ticket a new piece of mail belongs to
# Your domain name is recommended, so as not to pollute the namespace.
# once you start using a given tag, you should probably never change it. 
# (otherwise, mail for existing tickets won't get put in the right place

$rtname="YOU_HAVE_NOT_SET_rtname";  

# You should set this to your organization's DNS domain. For example,
# fsck.com or asylum.arkham.ma.us. It's used by the linking interface to 
# guarantee that ticket URIs are unique and easy to construct.

$Organization = "example.com";

# $user_passwd_min defines the minimum length for user passwords. Setting
# it to 0 disables this check
$MinimumPasswordLength = "5";

# What timezone is your RT server in? Currently used to process dates like
# "Tomorrow at 4pm." Once we have per-user timezones, this will just be a 
# default.
$ENV{'TZ'} = 'US/Eastern'; #TODO: Bogus hack to deal with Date::Manip whining


# RootDir is the root of the RT installation
$LogDir = "!!RT_LOG_PATH!!";

# }}}

# {{{ Database Configuration

# Database driver beeing used - i.e. MySQL.
$DatabaseType="!!DB_TYPE!!";

# host is the domain name of your database server
# if it's on localhost, leave it blank for enhanced performance
$DatabaseHost="!!DB_HOST!!";

#The name of the database user (inside the database) 
$DatabaseUser="!!DB_RT_USER!!";

# Password the DatabaseUser should use to access the database
$DatabasePassword="!!DB_RT_PASS!!";


# The name of the RT's database on your database server
$DatabaseName="!!DB_DATABASE!!";


# }}}

# {{{ Incoming mail gateway configuration

# If $BouncesToRTOwner is defined, RT will send mail that it believes 
# might be a bounce to $RT::OwnerEmail (Currently unimplemented)
$BouncesToRTOwner = 1;


# If $StoreBounces is defined, RT will record messages that it believes 
# might be autogenerated and might lead to mail loops. 
# As it does this, it will try to be careful not to send mail to the 
# sender of these messages (Currently unimplemented)
$StoreBounces = undef;


# This subroutine converts email addresses into canonical form.
# it takes one email address in and returns the proper canonical
# form. You can dump whatever your proper local config is in here
sub CanonicalizeAddress {
	my $email = shift;
	# Example: the following rule would treat all email
	# coming from a subdomain as coming from second level domain
	# foo.com
	#$email =~ s/\@(.*).foo.com/\@foo.com/;
	return ($email)
}

# }}}

# {{{ Outgoing mail configuration

#$MailAlias is a generic alias to send mail to for any request
#already in a queue.  
#RT is designed such that any mail which already has a ticket-id associated
#with it will get to the right place automatically.

#This is the default address that will be listed in 
#From: and Reply-To: headers of mail tracked by RT unless overridden
#by a queue specific address

$CorrespondAddress="RT::CorrespondAddress.not.set";

$CommentAddress="RT::CommentAddress.not.set";


#Sendmail Configuration

#What command is used to invoke sendmail on your system
$SendmailCommand="/usr/sbin/sendmail";

#What arguments should be passed to sendmail
#These options are good for most sendmail wrappers and workalikes
$SendmailArguments="-oi -t  ";
#For sendmail 8, you want the following options
#$SendmailArguments="-oi -t -ODeliveryMode=b -OErrorMode=m";

# }}}

# {{{ Logging

# Logging.  The default is to log anything except debugging
# information to a logfile.  Check the Log::Dispatch POD for
# information about how to get things by syslog, mail or anything
# else, get debugging info in the log, etc.  It might generally make
# sense to send error and higher by email to some administrator.  For
# heavens sake, be sure that the email goes directly to a mailbox, and
# not via RT :)  Mail loops will generate a critical log message.


use Log::Dispatch 1.6;
use Log::Dispatch::File;
use Log::Dispatch::Screen;

$Logger=Log::Dispatch->new();
$Logger->add(Log::Dispatch::File->new
	     ( name=>'rtlog',
	       min_level=>'debug',
	       filename=>"$LogDir/rt.log.".$$.".".$<, #log to rt.log.<pid>.<user>
	       mode=>'append',
	       callback => sub {my %p=@_; return "$p{message}\n"}
	     ));
$Logger->add(Log::Dispatch::Screen->new
	     ( name => 'screen',
	       min_level => 'debug',
	       stderr => 1
	     ));
# }}}

# {{{ Web UI configuration


# Define the directory name to be used for images in rt web
# documents.

# WebImagePath efines the directory name to be used for images in
# the web ui.  This must match the ``Alias'' Apache config
# option mentioned in the README.
$WebrtImagePath = "/images/";

#If you're putting the web ui somewhere other than at / on a server
$WebPath = "";

#Scheme, server and port for constructing urls to webrt

$WebBaseURL = "http://RT::WebBaseURL.not.configured:80/";

$WebURL = $WebBaseURL . $WebPath. "/";


#MasonComponentRoot is where your rt instance keeps its mason 
#html files
$MasonComponentRoot = "!!MASON_HTML_PATH!!";

#Where mason keeps its datafiles
$MasonDataDir = "!!MASON_DATA_PATH!!";


#This is from tobias' prototype web search UI. it may stay and it may go.
%WebOptions=
    (
     # This is for putting in more user-actions at the Transaction
     # bar.  I will typically add "Enter bug in Bugzilla" here.:
     ExtraTransactionActions => sub { return ""; },

     # Here you can modify the list view.  Be aware that the web
     # interface might crash if TicketAttribute is wrongly set.
     # Consult the docs (if somebody is going to write them?) your
     # local RT hacker or eventually the rt-users / rt-devel
     # mailinglists
     QueueListingCols => 
      [
       { Header     => 'Id',
	 TicketLink => 1,
	 TicketAttribute => 'Id'
	 },

      { Header     => 'Subject',
	 TicketAttribute => 'Subject'
	 },
       { Header => 'Requestor(s)',
	 TicketAttribute => 'RequestorsAsString'
	 },
       { Header => 'Status',
	 TicketAttribute => 'Status'
	 },


       { Header => 'Queue',
	 TicketAttribute => 'QueueObj->QueueId'
	 },



       { Header => 'Told',
	 TicketAttribute => 'LongSinceToldAsString'
	 },

       { Header => 'Age',
	 TicketAttribute => 'AgeAsString'
	 },

       { Header => 'Last',
	 TicketAttribute => 'LongSinceUpdateAsString'
	 },

       # TODO: It would be nice with a link here to the Owner and all
       # other request owned by this Owner.
       { Header => 'Owner',
	 TicketAttribute => 'OwnerObj->UserId'
       },
   
 
       { Header     => 'Take',
	 TicketLink => 1,
	 Constant   => 'Take',
	 ExtraLinks => '&Action=Take'
	 },

      ]
     );

# }}}


# {{{ Unimplemented features that don't yet need configuration

# {{{ MIME Object storage configuration
# 
# So far, this is all placeholders
#
#
# Maximum MIME Object Size

# Drop on the ground if it's over x kb
# Return to sender if it's over x kb

# MIME Object types to drop on the floor
# MIME Object types to return to sender
# MIME Object types to forward to RT Owner
# MIME Object types to store on disk
# MIME Object types to store in the database

# If an object doesn't meet any of the above criteria:

# Store on disk if it's over x kb

# Otherwise store it in the DB

# }}}

# {{{ Localization configuration

#  This is the default locale used by RT when deciding what version of the strings
# to show you
$DefaultLocale = "!!DEFAULT_LOCALE!!";

# This is the directory that .po files live in.

$LocalePath = "!!LOCALE_PATH!!";

# }}}

# {{{ RT Linking Interface


# Base path of the URI for local tickets
$TicketBaseURI = "fsck.com-rt://$Organization/$rtname/ticket/";


# A hash table of conversion subs to be used for transforming RT Link
# URIs to URLs in the web interface.  If you want to use RT towards
# locally installed databases, this is the right place to configure it.
# (All currently unimplemented.)
%URI2HTTP=
    (
      'http' => sub {return @_;},
      'https' => sub {return @_;},
      'ftp' => sub {return @_;},
     'fsck.com-rt' => sub {warn "stub!";},
     'mozilla.org-bugzilla' => sub {warn "stub!"},
     'fsck.com-kb' => sub {warn "stub!"}
     );

# A hash table of subs for fetching content from an URI
%ContentFromURI=   
    (
     'fsck.com-rt' => sub {warn "stub!";},
     'mozilla.org-bugzilla' => sub {warn "stub!"},
     'fsck.com-kb' => sub {warn "stub!"}
     );

# }}}

# }}}

# {{{  No User servicable parts inside 



# {{{ Signal handlers
## This is the default handling of warnings and die'ings in the code
## (including other used modules - maybe except for errors catched by
## Mason).  It will log all problems through the standard logging
## mechanism (see above).

$SIG{__WARN__} = sub {$RT::Logger->log(level=>'warning',message=>$_[0])};

#When we call die, trap it and log->crit with the value of the die.

$SIG{__DIE__}  = sub {
    unless ($^S || !defined $^S ) {

   	 $RT::Logger->crit("$_[0]"); 
	exit(-1);
	}
    else {
	    #Get out of here if we're in an eval
	    die $_[0];

	}	
};

# }}}

# }}}


1;
