#!/usr/bin/perl -w
#
# $Header$
# RT is (c) 1996-2000 Jesse Vincent (jesse@fsck.com);



package RT;
use strict;
use vars qw($VERSION $Handle $Nobody $SystemUser $item);


use lib "!!RT_LIB_PATH!!";
use lib "!!RT_ETC_PATH!!";

#This drags in  RT's config.pm
use config;
use Carp;

use RT::Handle;
use RT::CurrentUser;

#connect to the db
$RT::Handle = new RT::Handle($RT::DatabaseType);
$RT::Handle->Connect();


my $RT_System = new RT::CurrentUser(); #TODO how do we bootstrap?

$RT_System->Create(
		     UserId => 'RT_System',
		     RealName => 'The RT System itself',
		     Comments =>  'Do not delete or modify this user. It is integral to RT\'s internal database structures',
		     CanManipulate => '1',
		     Creator => '1');


my $CurrentUser = new RT::CurrentUser();
$CurrentUser->LoadByUserId('RT_System');
# {{{ Users

my @users = ( 
	     { 
	      UserId => 'Nobody',
	      RealName => 'Nobody in particular',
	      Comments => 'Do not delete or modify this user. It is integral to RT\'s internal data structures',
	      CanManipulate => '1',
	     },
	     
	     { 
	      UserId => 'root',
	      Gecos => 'root',
	      RealName => 'Enoch Root',
              Password => 'password',
	      EmailAddress => "root\@localhost",
	      Comments => 'SuperUser',
	      CanManipulate => '1',
	     }
	    );

# }}}

# {{{ ACL
my @acl = ( 
	   { PrincipalId => '0', 
	     PrincipalType => 'Everyone',
	     RightName => 'SuperUser',
	     RightScope => 'System',
	     RightAppliesTo => '0'
	   } 
	  );
# }}}

# {{{ Queues
my @queues = ( 
	      { QueueId => 'general',
		Description => 'The default queue',
		CorrespondAddress => "rt\@localhost",
		CommentAddress => "rt-comment\@localhost"
	      }
	     );

# }}}

# {{{ Scrips

my @scrips = (
	      {
	       Name => 'Autoreply', 
	       Description =>  'Sends an automatic response to the requestor when a ticket was created',
	       Type=>  'Create',
	       ExecModule => 'AutoReply',
	       DefaultTemplate => '1',
	       Argument => ''
	      },
	      {
	       Name =>			   'NotifyOwnerOnTransaction',
	       Description =>   'Sends mail to owner when anything happens',
	       Type => 			   'Any',
	       ExecModule =>	'Notify',
	       DefaultTemplate =>	'2',
	       Argument =>			   'Owner'
	      },
	      {
	       
	       Name =>			   'NotifyAdminWatchersOnCorrespond',
	       Description =>			  'Sends mail to administrative watchers when email comes in',
	       Type => 			  'Correspond,Create',
	       ExecModule =>			   'SendEmail',
	       DefaultTemplate =>			   '3',
	       Argument =>			   ''},
	      
	      
	      {
	       
	       Name =>			   'NotifyRegularWatchersOnCorrespond', 
	       Description =>			  'Send "official" mail to (external) Cc watchers and (external) requestors whenever correspondence comes in',
	       Type => 			   'Correspond',
	       ExecModule =>			   'SendEmail',
	       DefaultTemplate =>			   '4',
	       Argument =>			   ''
	      },
	      
	      {
	       
	       Name =>			   'NotifyAdminWatchersOnComment',
	       Description =>			   'Send mail to administrative watchers whenever comments come in',
	       Type => 			   'Comment',
	       ExecModule =>			   'SendEmail',
	       DefaultTemplate =>			   '5',
	       Argument =>			   'AdminCc'
	      },
	      
	      {
	       
	       Name =>			   'NotifyAllWatchersOnStatus', 
	       Description =>			   'Send mail to watchers whenever a ticket\'s status changes',
	       Type => 			   'Resolve/Stall/Open/Kill',
	       ExecModule =>			   'SendEmail',
	       DefaultTemplate =>			   '6',
	       Argument =>			   ''},
	      
	      {
	       
	       
	       Name =>			   'NotifyAllWatchersOnResolve', 
	       Description =>				   'Send mail to watchers whenever a ticket\'s status changes to resolved.', 
	       Type => 			   'Resolve',
	       ExecModule =>			   'SendEmailOnResolve',
	       DefaultTemplate =>			   '7',
	       Argument =>			   ''},
	      
	      {
	       
	       Name =>			   'NotifyAdminWatchersOnTransaction',
	       Description =>				  'Sends mail to owner when anything happens',
	       Type => 			  'Any',
	       ExecModule =>			   'Notify',
	       DefaultTemplate =>			   '2',
	       Argument =>			   'AdminCc'
	      },
	      
	      ##TODO: Get Notify.pm to support OldOwner + fix a template
	      #INSERT INTO Scrips VALUES (20, 'NotifyOldOwnerOnSteal',
	      #			  'Sends mail to the old owner when the ticket is stolen',
	      #			  'Steal','Notify',10,'OldOwner',
	      
	      
	      {
	       Name =>			   'StallDependentOnLink', 
	       Description =>			           'Stalls the dependent when a DependsOn link is made',
	       Type => 			   'Link',
	       ExecModule =>			   'StallDependent',
	       
	      },
	      
	      {
	       
	       Name =>			   'StallMemberOnLink', 
	       Description =>			           'Stalls the member when a MemberOf link is made',
	       Type => 			   'Link',
	       ExecModule =>			   'StallDependent',
	       Argument =>			   'MemberOf'} ,
	      
	      
	      {
	       
	       Name =>			   'OpenDependentOnResolve',
	       Description =>			           'Opens the dependent when the DependsOn is resolved',
	       Type => 			   'Resolve', 
	       ExecModule =>			   'OpenDependent',
	      },
	      
	      
	      {
	       
	       Name =>			   'ResolveMembers',
	       Description =>			           'Resolves all members when MemberOf is resolved',
	       Type => 			   'Resolve', 
	       ExecModule =>			   'ResolveMembers',
	      },
	      
	      
	      
	      {
	       
	       Name =>			   'NotifyWatchersofMembers', 
	       Description =>			   'Sends mail to the watchers of all tickets which are members of this ticket',
	       Type =>       'Correspond', 
	       ExecModule =>			   'Spam',
	       DefaultTemplate =>			   '4'
	      }
	     );

# Default templates
# Should eventually be created through some init script calling on the CLI admin tools
# }}}

# {{{ Templates
my @templates = (
{
#				id => 1,
				Title => 'Default Autoresponse Template', 
				Content => 'To: {$Ticket->RequestorsAsString}
Cc: {$Ticket->CcAsString}
Bcc: {$Ticket->AdminCcAsString}
Subject: AutoReply: {$Ticket->Subject}

       Greetings,
        This message has been automatically generated in response to your
message regarding \"{$Ticket->Subject()}\", the content of which appears below.
There is no need to reply to it now. The Support group has received
your message and it has been assigned a ticket ID of [{$rtname} #{$Ticket->id()}].
Please include the string

         [{$rtname} #{$Ticket->id}]
in the subject line of all future correspondence about this
problem. To do so, you may reply to this message.
                        Thank you,
                        The Support Group
                        {$Ticket->QueueObj->CorrespondAddress()}

-------------------------------------------------------------------------
{$Transaction->Message()->First()->Content()}
' },

{
#                  id => 2,
                  Title => 'Default transaction template',
                  Content => 'Reply-To: {$Ticket->QueueObj->CommentAddress} (Replies will be entered as comments)

{$Transaction->CreatedAsString}: Request {$Ticket->id} was acted upon.
Transaction: {$Transaction->Description}
       Queue: {$Ticket->QueueObj->QueueId}
     Subject: {my $z=$Transaction->Message()->First(); $z ? $z->Subject : "(No subject given)"}
       Owner: {$Ticket->OwnerObj->UserId}
  Requestors: {join(",",\@{$Ticket->Requestors->Emails()})}    
      Status: {$Ticket->Status}
 Ticket <URL: {$RT::WebURL}/Ticket/Display.html?id={$Ticket->id} >
-------------------------------------------------------------------------
{$Transaction->Message()->First()->Content() if $Transaction->Message()->First()}'},


{
#                  id => 3,
                  Title => 'Default admin correspondence template',
                  Content => 'Subject: {$Transaction->Message()->First()->Subject}
Content-Type: text/plain; charset=ISO-8859-1
To: {$Ticket->AdminCcAsString}

{$Transaction->IsInbound() ? "In" : "Out"}bound correspondence:

<URL: {$RT::WebURL}/Ticket/Display.html?id={$Ticket->id} >

{$Transaction->Message()->First()->Content()}' },


{
#                  id => 4,
                  Title => 'Default correspondence template',
                  Content =>  'Subject: {my $z=$Transaction->Message()->First(); $z ? $z->Subject : "(No subject given)"}
To: {$Ticket->RequestorsAsString}
Cc: {$Ticket->CcAsString}
Content-Type: text/plain; charset=ISO-8859-1

{$Transaction->Message()->First()->Content()}'},


{
#                  id => 5,
                  Title => 'Default admin comment template',
                  Content =>  'Subject: [Comment] {my $z=$Transaction->Message()->First(); return "(...)" unless $z; my $s=$z->Subject; $s =~ s/\\[Comment\\]//g; $comment =~ s/^Re//i; $s;}
Reply-To: {$Ticket->QueueObj->CommentAddress}
Content-Type: text/plain; charset=ISO-8859-1
To: {$Ticket->AdminCcAsString}

{$RT::WebURL}/Ticket/Display.html?id={$Ticket->id}
This is a comment.  It is not sent to the Requestor(s):

{$Transaction->Message()->First()->Content()}
'},


{

#                  id => 6,
                  Title => 'Ticket status changed',
                  Content =>  'Subject: Status Changed to: {$Transaction->NewValue}
Reply-To: {$Ticket->QueueObj->CorrespondAddress}
Content-Type: text/plain; charset=ISO-8859-1
To: {$Ticket->WatchersAsString}

{$RT::WebURL}/Ticket/Display.html?id={$Ticket->id}

{$Transaction->Message()->First()->Content()}
'},

{

#                  id => 7,
                  Title => 'Ticket Resolved',
                  Content => 'Subject: Ticket Resolved
Reply-To: {$Ticket->QueueObj->CorrespondAddress}
Content-Type: text/plain; charset=ISO-8859-1
To: {$Ticket->RequestorsAsString}
Cc: {$Ticket->CcAsString}

According to our records, your request has been resolved. If you have any
further questions or concerns, simply respond to this message.
'}
);

# }}}




print "Creating ACL...";
use RT::ACE;
for $item (@acl) {
    my $new_entry = new RT::ACE($CurrentUser);
    #Using an internal function. this should never be used outside of the bootstrap script
    my $return = $new_entry->_BootstrapRight(%$item);
    print $return.".";
}
print "done.\n";

print "Creating users...";
use RT::User;
foreach $item (@users) {
   my $new_entry = new RT::User($CurrentUser);
   my $return = $new_entry->Create(%$item);
  print $return.".";
}

print "done.\n";

print "Creating queues...";
    use RT::Queue;
for $item (@queues) {
    my $new_entry = new RT::Queue($CurrentUser);
    my $return = $new_entry->Create(%$item);
    print $return.".";
}

print "done.\n";
print "Creating scrips...";

    use RT::Scrip;
for $item (@scrips) {

    my $new_entry = new RT::Scrip($CurrentUser);
   
    my $return = $new_entry->Create(%$item);
    print $return.".";
}

print "done.\n";


print "Creating templates...";

    use RT::Template;
for $item (@templates) {
    my $new_entry = new RT::Template($CurrentUser);
    my $return = $new_entry->Create(%$item);
    print $return.".";
}
print "done.\n";

$RT::Handle->Disconnect();


1;

