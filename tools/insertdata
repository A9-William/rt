#!/usr/bin/perl -w
#
# $Header$
# RT is (c) 1996-2000 Jesse Vincent (jesse@fsck.com);



package RT;
use strict;
use vars qw($VERSION $Handle $Nobody $SystemUser $item);


use lib "!!RT_LIB_PATH!!";
use lib "!!RT_ETC_PATH!!";

#This drags in  RT's config.pm
use config;
use Carp;

use RT::Handle;
use RT::CurrentUser;

#connect to the db
$RT::Handle = new RT::Handle($RT::DatabaseType);
$RT::Handle->Connect();


my $RT_System = new RT::CurrentUser(); #TODO how do we bootstrap?

$RT_System->Create(
		     Name => 'RT_System',
		     RealName => 'The RT System itself',
		     Comments =>  'Do not delete or modify this user. It is integral to RT\'s internal database structures',
		     Privileged => '2',
		     Creator => '1');



#now that we bootstrapped that little bit, we can use the standard RT cli
# helpers  to do what we need

use RT::Interface::CLI  qw(CleanEnv LoadConfig DBConnect 
			   GetCurrentUser GetMessageContent);

#Clean out all the nasties from the environment
CleanEnv();

#Load etc/config.pm and drop privs
LoadConfig();

#Connect to the database and get RT::SystemUser and RT::Nobody loaded
DBConnect();


my $CurrentUser = new RT::CurrentUser();
$CurrentUser->LoadByName('RT_System');
# {{{ Users

my @users = ( 
	     { 
	      Name => 'Nobody',
	      EmailAddress => "nobody\@localhost",
	      RealName => 'Nobody in particular',
	      Comments => 'Do not delete or modify this user. It is integral ' .
	      'to RT\'s internal data structures',
	      Privileged => '2',
	     },

	     { 
	      Name => 'root',
	      Gecos => 'root',
	      RealName => 'Enoch Root',
              Password => 'password',
	      EmailAddress => "root\@localhost",
	      Comments => 'SuperUser',
	      Privileged => '1',
	     }
	    );

# }}}


# {{{ Groups 

my @groups = (
              {
               Name => 'Everyone',
	       Description => 'Pseudogroup for internal use',
	       Pseudo => '1',
              },
	      {
	       Name => 'Requestor',
	       Description => 'Pseudogroup for internal use',
	       Pseudo => '1',
	      },
	      {
	       Name => 'Cc',
	       Description => 'Pseudogroup for internal use',
	       Pseudo => '1',
	      },
	      {
	       Name => 'AdminCc',
	       Description => 'Pseudogroup for internal use',
	       Pseudo => '1',
	      },
	     );

# }}}

# {{{ ACL
my @acl = (  #TODO: make this actually take the serial # granted to root.
	   { PrincipalId => '1', 
	     PrincipalType => 'User',
	     RightName => 'SuperUser',
	     RightScope => 'System',
	     RightAppliesTo => '0'
	   }, 
           { PrincipalId => '2',
             PrincipalType => 'User',
             RightName => 'SuperUser',
             RightScope => 'System',
             RightAppliesTo => '0'
           },

           { PrincipalId => '3',
             PrincipalType => 'User',
             RightName => 'SuperUser',
             RightScope => 'System',
             RightAppliesTo => '0'
           }


	  );
# }}}

# {{{ Queues

my @queues = ( 
	      { Name => 'general',
		Description => 'The default queue',
		CorrespondAddress => "rt\@localhost",
		CommentAddress => "rt-comment\@localhost"
	      }
	     );

# }}}

# {{{ ScripActions

my @ScripActions = (
		    {
		     Name => 'NotifyRequestor',
		     Description =>       'Sends a message to the requestor',
		     ExecModule =>        'Notify',
		     Argument =>          'Requestor'
		    },

		    {
		     Name =>	          'NotifyOwnerAsComment',
		     Description =>       'Sends mail to owner',
		     ExecModule =>        'NotifyAsComment',
		     Argument =>          'Owner'
		    },
		    {
		     Name =>	          'NotifyOwner',
		     Description =>       'Sends mail to owner',
		     ExecModule =>        'Notify',
		     Argument =>          'Owner'
		    },
		    {
		     Name =>	          'NotifyAdminWatchersAsComment',
		     Description =>	  'Sends mail to administrative watchers as a comment',
		     ExecModule =>	  'NotifyAsComment',
		     Argument =>        'AdminCc'
		    },
		    {
		     Name =>	          'NotifyAdminWatchers',
		     Description =>	  'Sends mail to administrative watchers',
		     ExecModule =>	  'Notify',
		     Argument =>        'AdminCc'
		    },
		    
                    {
                     Name =>             'NotifyRequestorAndCcsAsComment',
                     Description =>      'Send mail to requestors as a comment',
                     ExecModule =>       'NotifyAsComment',
                     Argument =>         'Requestor,Cc'
                    },
		    
		    {
		     Name =>             'NotifyRequestorsAndCcs',
		     Description =>      'Send mail to requestors',
		     ExecModule =>       'Notify',
		     Argument =>         'Requestor,Cc'
		    },
		    
		    
		    {
		     Name =>	          'NotifyAllWatchersAsComment',
		     Description =>	  'Send mail to all watchers',
		     ExecModule =>	  'NotifyAsComment',
		     Argument =>          'All'
                    },
		    {
		     Name =>	          'NotifyAllWatchers',
		     Description =>	  'Send mail to all watchers',
		     ExecModule =>	  'Notify',
		     Argument =>          'All'
		    },
		    
		    {
		     Name =>	           'StallDependant (broken)',
		     Description =>        'Stalls the dependent tickets',
		     ExecModule =>	   'StallDependent',
		     Argument => ''
		    },
		    {
		     Name =>		   'OpenDependant (broken)',
		     Description =>        'Opens the dependent tickets',
		     ExecModule =>	   'OpenDependent',
		     Argument => ''
		    }
		    
		   );

# }}}

# {{{ ScripConditions

my @ScripConditions = (
		       {
			Name => 'OnCreate',
			Description =>  'When a ticket is created',
			ApplicableTransTypes =>  'Create',
			ExecModule => 'AnyTransaction',
		       },
		       
		       
		       {
			Name =>			   'OnTransaction',
			Description =>   'When anything happens',
			ApplicableTransTypes => 			   'Any',
			ExecModule =>	'AnyTransaction',
		       },
		       {
			
			Name =>	          'OnCorrespond',
			Description =>	  'Whenever correspondence comes in',
			ApplicableTransTypes => 		  'Correspond',
			ExecModule =>	  'AnyTransaction',
		       },
		       
		       
		       {
			
			Name =>			   'OnComment',
			Description =>			   'Whenever comments come in',
			ApplicableTransTypes => 	   'Comment',
			ExecModule =>			   'AnyTransaction'
		       },
		       {
			
			Name =>		   'OnStatus', 
			Description =>	   'Whenever a ticket\'s status changes',
			ApplicableTransTypes => 		   'Status',
			ExecModule =>	   'AnyTransaction',

		       },
		       {
			Name =>		   'OnResolve', 
			Description =>	   'Whenever a ticket\'s status changes to resolved.', 
			ApplicableTransTypes => 		   'Status',
			ExecModule =>	   'OnResolve'
		       },
		       {
			
			Name =>			   'OnLink', 
			Description =>	           'When a DependsOn link is made',
			ApplicableTransTypes => 	   'Link',
			ExecModule =>	          'OnNewDependency'
			
		       },
		       
		       {
			
			Name =>			   'OnResolve',
			Description =>	           'When a ticket is resolved',
			ApplicableTransTypes => 	   'Status', 
			ExecModule =>		   'OnResolve'
		       }
		       
		       
		       
		      );

# }}}

# {{{ Templates
my @templates = (
{
                Queue   => '0',
                Name => 'Autoreply',
				Description => 'Default Autoresponse Template', 
				Content => 
'Subject: AutoReply: {$Ticket->Subject}


       Greetings,
        This message has been automatically generated in response to your
message regarding "{$Ticket->Subject()}", the content of which appears below.
There is no need to reply to it now. The Support group has received
your message and it has been assigned a ticket ID of [{$rtname} #{$Ticket->id()}].
Please include the string

         [{$rtname} #{$Ticket->id}]
in the subject line of all future correspondence about this
problem. To do so, you may reply to this message.
                        Thank you,
                        The Support Group
                        {$Ticket->QueueObj->CorrespondAddress()}

-------------------------------------------------------------------------
{$Transaction->Message()->First()->Content()}
' },

{
#                  id => 2,
                Queue   => '0',
                Name => 'Transaction', 
                  Description => 'Default transaction template',
                  Content => '


{$Transaction->CreatedAsString}: Request {$Ticket->id} was acted upon.
Transaction: {$Transaction->Description}
       Queue: {$Ticket->QueueObj->Name}
     Subject: {my $z=$Transaction->Message()->First(); $z ? $z->Subject : "(No subject given)"}
       Owner: {$Ticket->OwnerObj->Name}
  Requestors: {join(",",\@{$Ticket->Requestors->Emails()})}    
      Status: {$Ticket->Status}
 Ticket <URL: {$RT::WebURL}/Ticket/Display.html?id={$Ticket->id} >
-------------------------------------------------------------------------
{$Transaction->Message()->First()->Content() if $Transaction->Message()->First()}'},


{

                  Queue   => '0',
                  Name => 'AdminCorrespondence',
                  Description => 'Default admin correspondence template',
                  Content => 'Subject: {$Transaction->Message()->First()->Subject}

{$Transaction->IsInbound() ? "In" : "Out"}bound correspondence:

<URL: {$RT::WebURL}/Ticket/Display.html?id={$Ticket->id} >

{$Transaction->Message()->First()->Content()}' },


{
                  Queue   => '0',
                  Name => 'Correspondence',
                  Description => 'Default correspondence template',
                  Content =>  '

{$Transaction->Message()->First()->Content()}'},


{
                  Queue   => '0',
                  Name => 'AdminComment',
                  Description => 'Default admin comment template',
                  Content =>  'Subject: [Comment] {my $z=$Transaction->Message()->First(); return "(...)" unless $z; my $s=$z->Subject; $s =~ s/\\[Comment\\]//g; $comment =~ s/^Re//i; $s;}


{$RT::WebURL}/Ticket/Display.html?id={$Ticket->id}
This is a comment.  It is not sent to the Requestor(s):

{$Transaction->Message()->First()->Content()}
'},


{
                  Queue   => '0',
                  Name => 'StatusChange',
                  Description => 'Ticket status changed',
                  Content =>  'Subject: Status Changed to: {$Transaction->NewValue}


{$RT::WebURL}/Ticket/Display.html?id={$Ticket->id}

{$Transaction->Message()->First()->Content()}
'},

{

                 Queue => '0',
                 Name => 'Resolved',
                  Description => 'Ticket Resolved',
                  Content => 'Subject: Ticket Resolved

According to our records, your request has been resolved. If you have any
further questions or concerns, please respond to this message.
'}
);

# }}}



print "Creating ACL...";
use RT::ACE;
for $item (@acl) {
    my $new_entry = new RT::ACE($CurrentUser);
    #Using an internal function. this should never be used outside of the bootstrap script
    my $return = $new_entry->_BootstrapRight(%$item);
    print $return.".";
}
print "done.\n";

print "Creating users...";
use RT::User;
foreach $item (@users) {
    my $new_entry = new RT::User($CurrentUser);
    my ($return, $msg) = $new_entry->Create(%$item);
    print "(Error: $msg)"   unless ($return);
    print $return.".";
}
print "done.\n";

print "Creating groups...";
use RT::Group;
foreach $item (@groups) {
   my $new_entry = new RT::Group($CurrentUser);
   my $return = $new_entry->Create(%$item);
  print $return.".";
}
print "done.\n";



print "Creating queues...";
use RT::Queue;
for $item (@queues) {
    my $new_entry = new RT::Queue($CurrentUser);
    my ($return, $msg) = $new_entry->Create(%$item);
    print "(Error: $msg)"   unless ($return);
    print $return.".";
}

print "done.\n";
print "Creating ScripActions...";

use RT::ScripAction;
for $item (@ScripActions) {
    my $new_entry = new RT::ScripAction($CurrentUser);
       my $return = $new_entry->Create(%$item);
    print $return.".";
}

print "done.\n";
print "Creating ScripConditions...";

use RT::ScripCondition;
for $item (@ScripConditions) {
    my $new_entry = new RT::ScripCondition($CurrentUser);
    my $return = $new_entry->Create(%$item);
    print $return.".";
}

print "done.\n";


print "Creating templates...";

    use RT::Template;
for $item (@templates) {
    my $new_entry = new RT::Template($CurrentUser);
    my $return = $new_entry->Create(%$item);
    print $return.".";
}
print "done.\n";

$RT::Handle->Disconnect();


1;

