#!/usr/bin/perl -w

# $Header$

#  RT 1.0 -> RT 2.0 import tool.
#  RT is (c) 1996-2001 Jesse Vincent <jesse@fsck.com>


my $RT1USER = "root";
my $RT1PASSWORD = 'password';
my $RT1DATABASE = "rt";
my $RT1HOST = "localhost";
my $RT1DATA = "/opt/rt/transactions";
my $EMAILDOMAIN = "example.com"; # user_id@EMAILDOMAIN for missing RT1 emails
my $DEFAULTQUEUE = 'second'; #Qeuue to put tickets from deleted queues, etc. in.
my $Debug = 2;


use strict;
use Carp;
use Getopt::Long qw(:config pass_through);

use lib "!!RT_LIB_PATH!!";
use lib "!!RT_ETC_PATH!!";

use RT::Interface::CLI  qw(CleanEnv LoadConfig DBConnect 
			   GetCurrentUser GetMessageContent);
use Date::Format;
use MIME::Entity;
use MIME::Parser;
use RT::User;
use RT::Queue;
use RT::Ticket;
use RT::Transaction;
#Clean out all the nasties from the environment
CleanEnv();

#Load etc/config.pm and drop privs
LoadConfig();

#Connect to the database and get RT::SystemUser and RT::Nobody loaded
DBConnect();

#  open the rt1 database, too

my $dsn = "DBI:mysql:database=$RT1DATABASE;host=$RT1HOST;";
my $dbh = DBI->connect($dsn, $RT1USER, $RT1PASSWORD)
    or die "Can't connect to RT1 database: ".$DBI::errstr;

#  go through all system users and add them to rt2

MigrateUsers();

# lets create a place to put per-queue keywords. (areas)

my $queue_keyword = RT::Keyword->new($RT::SystemUser);
$queue_keyword->Create(Name => 'Queues', Parent => 0);

#  go through all the RT1 queues and create rt2 queues

MigrateQueues();

#  import tickets from RT1.

MigrateTickets();

print "Ok. We're all done here. Check things over very carefully. 
Conversion is an unproven science.\n";

exit(0);


# {{{ Subroutines and helpers

# {{{ sub MigrateQueues

sub MigrateQueues {


    print "Deleting queue 'general'\n";
    $RT::Handle->SimpleQuery("DELETE FROM Queues where Name = 'general'");

    print "Now adding queues...\n";

    # Load the RT1 queues
    my $sth = ExecStatement("select queue_id, mail_alias, comment_alias, 
    default_prio, default_final_prio, default_due_in, m_owner_trans,
    m_members_trans, m_user_trans, m_user_create, m_members_corresp,
    m_members_comment, m_user_resolve, allow_user_create
    from queues");
    
    #Iterate through our queues and create new queue objects
    while (my @row = $sth->fetchrow_array()) {
	my $queue = RT::Queue->new($RT::SystemUser);

	print "Adding queue ".$row[0]."...";

	# Try to load up the current queue by name. avoids duplication.
	$queue->Load($row[0]);
	
	#if the queue isn't there, create one.
	unless ($queue->id) {
	    my ($val, $msg) = 
	      $queue->Create(Name => $row[0],
			     Description => 'Imported from RT 1.0',
			     CorrespondAddress => $row[1],
			     CommentAddress => $row[2],
			     InitialPriority => $row[3],
			     FinalPriority => $row[4],
			     DefaultDueIn => $row[5]);
	    	    
	    if ($val == 0) {
		warn "failed: $msg\n";
	    }
	    else {
		print "...added\n";
	    }
	}
	
	print "Adding scrips for queue ".$queue->Name . "...";
	
	# Add scrips to mimic RT1's behavior
	if ($row[6]) { #m_owner_trans

	    my $scrip = new RT::Scrip($RT::SystemUser);
	    $scrip->Create( Queue => $queue->id,
			    Template => 'Transaction',
			    ScripAction => 'NotifyOwner',
			    ScripCondition => 'OnTransaction');
	}
	if ($row[7] ) { # m_members_trans
	    my $scrip = new RT::Scrip($RT::SystemUser);
	    $scrip->Create( Queue => $queue->id,
			    Template => 'Transaction',
			    ScripAction => 'NotifyAdminCcs',
			    ScripCondition => 'OnTransaction');   
	    
	}
	if ($row[8] ) { # m_user_trans,
	    my $scrip = new RT::Scrip($RT::SystemUser);
	    $scrip->Create( Queue => $queue->id,
			    Template => 'Transaction',
			    ScripAction => 'NotifyRequestorsAndCcs',
			    ScripCondition => 'OnTransaction');   
	}
	if ($row[9] ) {  # m_user_create
	    my $scrip = new RT::Scrip($RT::SystemUser);
	    $scrip->Create( Queue => $queue->id,
			    Template => 'Autoreply',
			    ScripAction => 'AutoreplyToRequestors',
			    ScripCondition => 'OnCreate');
	}
	if ($row[10]) { # m_members_corresp
	    my $scrip = new RT::Scrip($RT::SystemUser);

	    $scrip->Create( Queue => $queue->id,
			    Template => 'AdminCorrespondence',
			    ScripAction => 'NotifyAdminCcs',
			    ScripCondition => 'OnCorrespond');
	}
	if ($row[11]) { # m_members_comment
	    my $scrip = new RT::Scrip($RT::SystemUser);
	    $scrip->Create( Queue => $queue->id,
			    Template => 'AdminComment',
			    ScripAction => 'NotifyAdminCcsAsComment',
			    ScripCondition => 'OnComment');
	}
	
	print "done.\n";

	# Grant ACLs to 'Everyone' to create requests and see queue if 
	# allow_user_create is granted.
	if ($row[13]) {
	    print "Allowing public ticket creation.";
	    my $everyone = RT::Group->new($RT::SystemUser);
	    $everyone->Load('Everyone');
	    $everyone->GrantQueueRight( RightName => 'SeeQueue', 
					RightAppliesTo => $queue->id);
	    $everyone->GrantQueueRight( RightName => 'CreateTicket', 
					RightAppliesTo => $queue->id);
	}


	#Lets get the areas for this queue
	MigrateAreas($queue);
	MigrateQueueACLandAdminCcs($queue);
	print "\n";
    }
    
}
# }}}

# {{{ sub MigrateQueueACLandAdminCcs

sub MigrateQueueACLandAdminCcs {
    my $queue = shift;

    my @displayrights = ( "SeeQueue", "ShowTemplate", "ShowScrips", 
			  "ShowTicket", "ShowTicketComments");
    my @manipulaterights = ( "CreateTicket", "ReplyToTicket", 
			     "CommentOnTicket", "OwnTicket", 
			     "ModifyTicket", "DeleteTicket");
    my @adminrights = ( "ModifyACL", "ModifyQueueWatchers", 
			"AdminKeywordSelects", "ModifyTemplate",
			    "ModifyScrips");
    
    print "Granting queue rights.\n";
    
    my $sth = ExecStatement( "SELECT * from queue_acl WHERE " .
			     "queue_id = " .  $dbh->quote($queue->Name ));
    
    while (my $row = $sth->fetchrow_hashref()) {
	my @rights;
	
	print " Granting rights for: ".$row->{'user_id'}." ";
	
	@rights = (@rights, @displayrights) if ($row->{'display'});
	@rights = (@rights, @manipulaterights) if ($row->{'manipulate'});
	@rights = (@rights, @adminrights) if ($row->{'admin'});
	
	my $user = RT::User->new($RT::SystemUser);
	$user->Load($row->{'user_id'});
	
	unless ($user->id) {
	    print "Couldn't find user ".$row->{'user_id'}. 
	      ". Not granting rights\n";
	    return();
	}
	
	foreach my $right (@rights) {
	    print "$right...";
	    $user->GrantQueueRight( RightName => $right,
				    RightAppliesTo => $queue->id);
	}
	
	print "...adding as AdminCc.";
	$queue->AddAdminCc(Owner => $user->id);

	print ".\n";
    }
    
}



# }}}

# {{{ sub MigrateAreas

sub MigrateAreas {
    my $queue = shift;
    
    print "Adding current areas for queue ". $queue->Name ."\n";
    
    #Find out what areas we have for this queue in RT1..
    my $sth = ExecStatement("SELECT area from queue_areas where queue_id = ".$dbh->quote($queue->Name));
    
    my $rows = $sth->rows;
    
    print "Found $rows areas. Now adding keywords for them.\n";
    #If we have any...

    #Create /QueueName
    my $queue_keyword = RT::Keyword->new($RT::SystemUser);
    my ($val, $msg) = 
      $queue_keyword->Create( Name => $queue->Name,
			      Description => 'Keywords for queue'.$queue->Name,
			      Parent => 0 );
    
    
	
    #Create /QueueName/Area/
    my $area_keyword = RT::Keyword->new($RT::SystemUser);
    my ($area, $areamsg) = 
      $area_keyword->Create( Name => 'Area',
			     Description => 'Autocreated by RT 1.0 import',
			     Parent => $val );
    
    if ($rows) {
	#Create all the areas underneath /QueueName/Area/
	while (my @row = $sth->fetchrow()) {
	    my $this_area = RT::Keyword->new($RT::SystemUser);
	    $this_area->Create (Name => $row[0],
				Description => 'Autocreated by RT 1.0 import',
				Parent => $area);
	}	
	

	#Create the 'Area' keyword select
	print "Creating 'Area' KeywordSelect...\n"; 
	my $ks = new RT::KeywordSelect($RT::SystemUser);
	$ks->Create(Name => 'Area',
		    Keyword => $area,
		    ObjectType => 'Ticket',
		    ObjectField => 'Queue',
		    ObjectValue => $queue->id,
		    Single => 1,
		    Depth => 1);
	
    }
}

# }}}

# {{{ sub MigrateUsers 

sub MigrateUsers {

    print "Deleting user'root'\n";
    $RT::Handle->SimpleQuery("DELETE FROM Users where Name = 'root'");

    print "Importing users...\n";
    
    #load the RT1 users
    my $sth = ExecStatement("select user_id, real_name, password, 
         email, phone, office, comments, admin_rt from users"); 

    while (my @row = $sth->fetchrow_array()) {

	print "Importing user $row[0]...";
	#iterate through the RT1 users list and create new RT2 users.
	my $user = RT::User->new($RT::SystemUser);
	
	#clean up bogus email addresses
	$row[3] = $row[0]."\@$EMAILDOMAIN" if ($row[3] eq "");

	my ($return, $msg) =  $user->Create( Name => $row[0],
					     Gecos => $row[0],
					     RealName => $row[1],
					     Password => $row[2],
					     EmailAddress => $row[3],
					     WorkPhone => $row[4],
					     Comments => $row[6],
					     Privileged => 1);
	if ($return == 0) {
	    print "failed: $msg\n";
	    next;
	}

	print "...added ";

	if ($row[7]) {
	    $user->GrantSystemRight(RightName => 'SuperUser');
	    print " as superuser";
	}
	print "\n";
    }
    
    $sth->finish();
        
}

# }}}

# {{{ sub MigrateTickets

sub MigrateTickets {

    print "Importing tickets...\n";
    my $sth = ExecStatement('select * from each_req');
    
    my @merges;

    while (my $row = $sth->fetchrow_hashref()) {

	print "\n".$row->{'serial_num'}.".";

	# {{{ If this ticket is merged, tell RT2.
	
	if ($row->{'effective_sn'} and 
	    ($row->{'effective_sn'} != $row->{'serial_num'})) {
	    
	    print "merging into ".$row->{'serial_num'}."...";
	    
	    push @merges, { ticket => $row->{'serial_num'},
			    mergeinto => $row->{'effective_sn'}};
	    
	}
	
	# }}}
	
	my @requestors = split(',',$row->{'requestors'});
	
	my $owner = new RT::User($RT::SystemUser);
	$owner->Load($row->{'owner'});

	
	my $queue = new RT::Queue($RT::SystemUser);
	$queue->Load($row->{'queue_id'});
	unless ($queue->id) {
	    $row->{'queue_id'} = $DEFAULTQUEUE;
	}	
	
	$row->{'status'} = 'resolved' 
	  if ($row->{'effective_sn'} and 
	      ($row->{'effective_sn'} != $row->{'serial_num'}));


	
	# {{{ Parse these dates
	
	my $due = new RT::Date($RT::SystemUser);
	$due->Set (Format => 'unix', Value => $row->{'date_due'})
	  if (defined $row->{'date_due'});
	
	my $told =  new RT::Date($RT::SystemUser);
	$told->Set (Format => 'unix', Value => $row->{'date_told'})
	  if (defined $row->{'date_old'});
	
	my $created =  new RT::Date($RT::SystemUser);
	$created->Set (Format => 'unix', Value => $row->{'date_created'})
	  if (defined $row->{'date_created'});
	
	my $updated =  new RT::Date($RT::SystemUser);
	$updated->Set (Format => 'unix', Value => $row->{'date_acted'})
	  if (defined $row->{'date_acted'});
	
	# }}}

	my $ticket = new RT::Ticket($RT::SystemUser);
	my ($id, $msg) = 
	  $ticket->Import( id => $row->{'serial_num'},
			   Queue => $row->{'queue_id'},
			   Status => $row->{'status'},
			   Requestor => \@requestors,
			   Owner => $owner->id,
			   Subject => $row->{'subject'},
			   Priority => $row->{'priority'},
			   FinalPriority => $row->{'final_priority'},
			   InitialPriority => $row->{'initial_priority'},
			   Due => $due->ISO,
			   Told => $told->ISO,
			   Created => $created->ISO,
			   Updated => $updated->ISO);
	

	$queue = $ticket->QueueObj();
	
	#If the ticket has an area, add it.
	if ($row->{'area'}) {
	    my $area_sel = $queue->KeywordSelect('Area');
	    
	    my $areaobj = new RT::Keyword($RT::SystemUser);
	    $areaobj->LoadByPath('/Queues/'.$ticket->QueueObj->Name.
				 '/Area/'.$row->{'area'});
	    
	    # If the area doesn't exist in the database,
	    # it's a disabled area. We need to create and disable it.
	    unless ($areaobj->id) {
		my $queue_area_obj = new RT::Keyword($RT::SystemUser);
		$queue_area_obj->LoadByPath('/Queues/'.$ticket->QueueObj->Name.
					    '/Area');
		$areaobj->Create(Name => $row->{'area'},
				 Description => 'Autocreated by RT 1.0 import',
				 Parent => $queue_area_obj->id);
		$areaobj->SetDisabled('1');
	    }

	    # create the new objectkeyword. bypass the Ticketobj so we don't
	    # get a transaction created for us.
	    my $ObjectKeyword = new RT::ObjectKeyword($RT::SystemUser);
	    my $result = $ObjectKeyword->Create( Keyword => $areaobj->id,
						 ObjectType => 'Ticket',
						 ObjectId => $row->{'serial_num'},
						 KeywordSelect => $area_sel->Id );
	}

	
        MigrateTransactions($row->{'serial_num'}, $ticket);
	

    }
    MigrateMerges(@merges);
    
}

# }}}  

# {{{ sub MigrateTransactions

sub MigrateTransactions {
    my $ticket_id = shift;
    my $ticket = shift;
    
    print "..transactions: ";
    
    my $sth = ExecStatement('SELECT * FROM transactions where serial_num = '.
			    $ticket_id);
    my $Status = "open";
    my $Queue = "(unknown)";
    my $Area = '';
    my $Subject = '';
    my $Owner = $RT::Nobody->Id;
    my $Priority = $ticket->InitialPriority();
    my $FinalPriority = $ticket->Priority();

    while (my $row = $sth->fetchrow_hashref()) {  
	my (%trans_args, $MIMEObj, $trans_file);
	
	warn "transaction $row->{id}\n" if $Debug;
	
	my $load_content = 0;
	$trans_args{'Type'} = '';
	$trans_args{'Field'} = '';
	
	# {{{ Convert transaction type from RT1 to RT2
	if ( ( $row->{type} eq 'create' ) or ($row->{'type'} eq 'import') ) {
	    $load_content = 1;
	    $trans_args{'Type'} = "Create";
	} 
	elsif ( $row->{type} eq 'status' ) {
	    $trans_args{'Type'} = "Status";
	    $trans_args{'Field'} = "Status";
	    $trans_args{'OldValue'} = $Status;
	    $trans_args{'NewValue'} = $row->{trans_data};
	    $Status = $row->{trans_data};
	} 
	elsif ( $row->{type} eq 'correspond' ) {
	    $load_content = 1;
	    $trans_args{'Type'} = "Correspond";
	} 
	elsif ( $row->{type} eq 'comments' ) {
	    $load_content = 1;
	    $trans_args{'Type'} = "Comment";
	} 
	elsif ( $row->{type} eq 'queue_id' ) {
	    $trans_args{'Type'} = "Set";
	    $trans_args{'Field'} = "Queue";
	    $trans_args{'OldValue'} = $Queue;
	    $trans_args{'NewValue'} = $row->{trans_data};
	    $Queue = $row->{trans_data};
	} 
	elsif ( $row->{type} eq 'owner' ) {

	    $trans_args{'Type'} = "Owner";
	    $trans_args{'Field'} ="Owner";
	    $trans_args{'OldValue'} = $Owner;
	    $row->{trans_data} ||= 'Nobody';
	    
	    my $new_user = new RT::User($RT::SystemUser);
	    $new_user->Load($row->{'trans_data'});
	    $trans_args{'NewValue'} = $new_user->Id;
	    
	    my $actor = new RT::User($RT::SystemUser);
	    $actor->Load($row->{'actor'});
	    
	    #take/give
	    if ( $Owner == $RT::Nobody->Id 
		 && $row->{trans_data} eq $row->{actor} ) {
		$trans_args{'Type'} = 'Take';
	    } elsif ( ($Owner == $actor->Id) and 
		      ($new_user->Id == $RT::Nobody->Id) ) {
		$trans_args{'Type'} = 'Untake';
	    } elsif ( $Owner != $RT::Nobody->Id) {
		$trans_args{'Type'} = 'Steal';
	    } else {
		$trans_args{'Type'} = 'Give';
	    }	
	    
	    $Owner = $new_user->Id;
	    
	} 
	elsif ( $row->{type} eq 'effective_sn' ) {
	    $trans_args{'Type'} = "AddLink";
	    $trans_args{'Field'} ="MemberOf";
	    $trans_args{'Data'} = "Ticket ". $ticket_id. 
	      " MergedInto ticket ". $row->{trans_data};
	    
	} 
	elsif ( $row->{type} eq 'area' ) {
	    $trans_args{'Type'} = "Keyword";
	    $trans_args{'OldValue'} = $Area;
	    $trans_args{'NewValue'} = $row->{trans_data};
	    $Area = $row->{trans_data};
	} 
	elsif ( $row->{type} eq 'requestors' ) {
	    $trans_args{'Type'} = "AddWatcher";
	    $trans_args{'Field'} ="Requestor";
	    $trans_args{'NewValue'} = $row->{trans_data};

	} 
	elsif ( $row->{type} eq 'date_due' ) {
	    $trans_args{'Type'} = "Set";
	    $trans_args{'Field'} ="Due";
	    my $date = new RT::Date($RT::SystemUser);
	    $date->Set( Format=>'unix', Value=>$row->{trans_data} );
	    $trans_args{'NewValue'} = $date->ISO();
	} 
	elsif ( $row->{type} eq 'subject' ) {
	    $trans_args{'Type'} = "Set";
	    $trans_args{'Field'} ="Subject";
	    $trans_args{'OldValue'} = $Subject;
	    $trans_args{'NewValue'} = $row->{trans_data};
	    $Subject = $row->{trans_data};
	    
	} 
	elsif ( $row->{type} eq 'priority' ) {
	    $trans_args{'Type'} = "Set";
	    $trans_args{'Field'} ="Priority";
	    $trans_args{'OldValue'} = $Priority;
	    $trans_args{'NewValue'} = $row->{'trans_data'};
	    $Priority = $row->{'trans_data'};
	    
	} 
	elsif ( $row->{type} eq 'final_priority' ) {
	    $trans_args{'Type'} = "Set";
	    $trans_args{'Field'} ="FinalPriority";
	    $trans_args{'OldValue'} = $FinalPriority;
	    $trans_args{'NewValue'} = $row->{'trans_data'};
	    $FinalPriority = $row->{'trans_data'};
	    
	} 
	elsif ( $row->{type} eq 'date_told' ) {
	    $trans_args{'Type'} = "Set";
	    $trans_args{'Field'} = "Told";
	    
	    my $date = new RT::Date($RT::SystemUser);
	    $date->Set( Format=>'unix', Value=>$row->{trans_data} );
	    $trans_args{'NewValue'} = $date->ISO();
	    
	} else {
	    die "unrecognized transaction type: $row->{type}";
	}

	# }}}
	
	# {{{ Try to find a file for the content if we need to
	my $filename = $row->{serial_num}.".".$row->{id};
	
	if ( $load_content ) {
	    my $file = 
	      time2str("$RT1DATA/%Y/%b/%e/",$row->{trans_date},'PST');

	    $file .= $filename;
	    $file =~ s/ //;
	    
	    
	    my $file2 = 
	      time2str("$RT1DATA/%Y/%b/%e/",$row->{trans_date} + 43200,'PST');
	    $file2 .= $filename;
	    $file2 =~ s/ //;
	    my $file3 = 
	      time2str("$RT1DATA/%Y/%b/%e/",$row->{trans_date} - 43200,'PST');
	    $file3 .= $filename;
	    $file3 =~ s/ //;
	    
	    $trans_file = -e $file ? $file : -e $file2 ? $file2 : -e $file3 ? $file3 : '' or
	      warn "none of $file, $file2 or $file3 exist\n";
	    warn "Content is in $trans_file\n";
	}
	# }}}
	
	# {{{ if we need to get the content out of the database
	
	if ( $trans_file ) {
	    warn "  file $trans_file\n" if $Debug;
	    
	    #parse $trans_file
	    open(FILE,"<$trans_file") or die $!;
	    
	    
	    my(@headers, @body);
	    my $headers = 0;
	    while (<FILE>) {
		if ( /^--- Headers Follow ---$/ ) {
		    $headers = 1;
		    next;
		} elsif ( $headers ) {
		    next if /^\s*$/;
		    next if /^>From /;
		    push @headers, $_;
		} else {
		    push @body, $_;
		}
	    }
	    
	    #clean up files with false multipart Content-type
	    my @n_headers;
	    while ( my $header = shift @headers ) {
		if ( $header =~ /^content-type:\s*multipart\/(alternative|mixed|report|signed|digest|related)\s*;/i ) {
		    my $two = 0;
		    my $boundary;
		    if ( $header =~ /;\s*boundary="?([\-\w\.\=\/\+\%]+)"?/i ) {
			$boundary = $1;
		    } elsif ( $header =~ /;\s*boundary=\s*$/i )  {
			#special case for actual boundary on next line
			die unless $headers[0] =~ /\s+"?([\-\w\.\=\/\+\%]+)"?/i;
			$boundary = $1;
			$two = 1;
		    } elsif ( $headers[0] =~ /(^|;)\s*boundary="([ \-\w\.\=\/\+\%]+)"/i ) { #embedded space, quotes not optional
			$boundary = $2;
			$two = 1;
		    } elsif ( $headers[0] =~ /(^|;)\s*boundary="?([\-\w\.\=\/\+\%]+)"?/i ) {
			$boundary = $2;
			$two = 1;
		    } elsif ( $headers[1] =~ /(^|;)\s*boundary="?([\-\w\.\=\/\+\%]+)"?/i ) {
			$boundary = $2;
			$two = 2;
		    } elsif ( $headers[2] =~ /(^|;)\s*boundary="?([\-\w\.\=\/\+\%]+)"?/i ) {
			#terrible false laziness.
			$boundary = $2;
			$two = 3;
		    } else {
			die "can't parse $header for boundry";
		    }
		    warn "looking for $boundary in body\n";
		    unless ( grep /^(\-\-)?\Q$boundary\E(\-\-)?$/, @body ) {
			splice(@headers, 0, $two);
			until ( !scalar(@headers) || $headers[0] =~ /^\S/ ) {
			    warn "**WARNING throwing away header fragment: ". shift @headers;
			}
			warn "false Content-type: header removed\n";
			next;
		    }
		}
		push @n_headers, $header;
	    }
	    
	    warn "    parsing..\n";
	    my $parser = new MIME::Parser;
	    $parser->output_to_core(1);
	    $parser->extract_nested_messages(0);
	    $MIMEObj = $parser->parse_data( [ @n_headers, "\n", "\n", @body ] );
	    warn "    parsed\n";
	} 

	# }}}
	
	if ( $trans_args{'Type'} ) {
	    
	    # {{{ Figure out the transaction actor. create a user if we need to
	    
	    my $User = new RT::User($RT::SystemUser);
	    
	    if ($row->{'actor'}) {
	    	$User->Load( $row->{'actor'} );
	        unless ($User->Id) {
		    $User->LoadByEmail($row->{'actor'});
		}
	        unless ($User->Id) {
		    my $Address = $row->{'actor'};
		    $Address .= "\@$EMAILDOMAIN" unless $Address =~ /\@/;
		    
		    $User->LoadByEmail($Address);
		    
		    unless ($User->Id) {
			
			my ($Val, $Message) = $User->Create(Name => $row->{'actor'},
							    EmailAddress => $Address,
							    Password => undef,
							    Privileged => 0,
							    Comments => undef
							   );
			
			unless($Val) {
			    die "couldn't create User for $Address: $Message\n";
			}
		    }
		};
		
	    }
	    else {
		$User->Load($RT::Nobody->Id);
	    }
	    # }}}
	    carp "We couldn't find or create ".$row->{'actor'}. ". This should never happen"
	      unless ($User->Id);
	    

	    my $created = new RT::Date($RT::SystemUser);
	    $created->Set( Format=>'unix', Value=>$row->{'trans_date'});
	    
	    my $trans = new RT::Transaction($User);
	    
	    # Allow us to set the 'Created' attribute. 
	    
	    $trans->{'_AccessibleCache'}{Created} = { 'read'=>1, 'write'=>1 };
	    $trans->{'_AccessibleCache'}{Creator} = { 'read'=>1, 'auto'=>1 };
	    
	    my ($transaction, $msg) = 
	      $trans->Create( Ticket => $ticket_id,
			      Type => $trans_args{'Type'},
			      Data => $trans_args{'Data'},
			      Field => $trans_args{'Field'},
			      NewValue => $trans_args{'NewValue'},
			      OldValue => $trans_args{'OldValue'},
			      MIMEObj => $MIMEObj,
			      Created => $created->ISO,
			      ActivateScrips => 0
			    );
	    
	    die("Couldn't create transaction for ".$row->{'id'} . "\n$msg\n") 
	      unless $transaction;

	    print $trans->id.".";
	}
	else {
	    die "Couldn't parse ". $row->{'id'};
	}
	
    }
    print "done.\n";
}

# }}}


# {{{ sub MigrateMerges 

sub MigrateMerges {
    my @merges = shift;
    
    foreach my $row (@merges) {
	print "Merging ".$row->{'ticket'} ." into ". $row->{'mergeinto'} ."\n";
	
	# Store the link in the DB.
	
	my $link = RT::Link->new($RT::SystemUser);
	my ($linkid) = $link->Create(Target => $row->{'mergeinto'},
				     Base => $row->{'ticket'}, 
				     Type => 'MergedInto');
	
	my $ticket = new RT::Ticket($RT::SystemUser);
	$ticket->Load($row->{'ticket'});
	
	if ($ticket->id != $row->{'ticket'}) {
	    die "Ticket mismatch ".$ticket->id ." and ".$row->{'ticket'}."\n";
	}
	my ($val, $msg) = 
	  $ticket->__Set(Field => 'EffectiveId', Value => $row->{'mergeinto'});
    
	unless ($val) {
	    $RT::Logger->err(" couldn't set EffectiveId: $msg\n");
	}	
    }


}

# }}}

# {{{ sub ExecStatement

sub ExecStatement {
    my $statement = shift;
    
    my $sth = $dbh->prepare($statement);
    $sth->execute() or 
      die("Can't exec statement: $statement\nReason:" . $DBI::errstr."\n");
    
    return ($sth);
}

# }}}

# }}}
