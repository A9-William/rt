#!/usr/bin/perl
#
# $Header$
# RT is (c) 1996-2000 Jesse Vincent (jesse@fsck.com);


$ENV{'PATH'} = '/bin:/usr/bin';    # or whatever you need
$ENV{'CDPATH'} = '' if defined $ENV{'CDPATH'};
$ENV{'SHELL'} = '/bin/sh' if defined $ENV{'SHELL'};
$ENV{'ENV'} = '' if defined $ENV{'ENV'};
$ENV{'IFS'} = ''		if defined $ENV{'IFS'};

package RT;
use strict;
use vars qw($VERSION $Handle $Nobody $SystemUser);
use Getopt::Long;

$VERSION="!!RT_VERSION!!";

use lib "!!RT_LIB_PATH!!";
use lib "!!RT_ETC_PATH!!";

#This drags in  RT's config.pm
use config;
use Carp;

use RT::Handle;
$RT::Handle = new RT::Handle($RT::DatabaseType);
{
$RT::Handle->Connect();
}

use RT::CurrentUser;
#RT's system user is a genuine database user. its id lives here

$RT::SystemUser = new RT::CurrentUser();
$RT::SystemUser->LoadByUserId('RT_System');

#RT's "nobody user" is a genuine database user. its ID lives here.
$RT::Nobody = new RT::CurrentUser();
$RT::Nobody->LoadByUserId('Nobody');

my $CurrentUser = GetCurrentUser();

# {{{ commandline flags 
my ( @id,
     @limit_queue,
     @limit_status,
     @limit_owner,
     @limit_priority,
     @limit_final_priority,
     @limit_requestor,
     @limit_subject,
     @limit_body,
     @limit_created,
     @limit_due,
     @limit_starts,
     @limit_started,
     $limit_first,
     $limit_rows,
     $history,
     $summary,
     $create,
     @requestors,
     @cc,
     @admincc,
     @status,
     $subject,
     $owner,
     $queue,
     $time_left,
     $priority,
     $final_priority,
     $due,
     $starts,
     $started,
     $contacted,
     $comment,
     $reply,
     $source,
     $edit,
     @dependson,
     @memberof, 
     @relatedto,
     @keywords,
     $time_taken,
     $verbose,
     $debug,
   $help,
   $version);

# }}}
# {{{    args
my @args =("id=s" => \@id,
	   "limit-queue=s" => \@limit_queue,
	   "limit-status=s" => \@limit_status,
	   "limit-owner=s" => \@limit_owner,
	   "limit-priority=s" => \@limit_priority,
	   "limit-final-priority=s" => \@limit_final_priority,
	   "limit-requestor=s" => \@limit_requestor,
	   "limit-subject=s" => \@limit_subject,
	   "limit-body=s",	\@limit_body,
	   "limit-created=s" => \@limit_created,
	   "limit-due=s" =>	\@limit_due,
	   "limit-starts=s" => \@limit_starts,
	   "limit-started=s" => \@limit_started,
	   "limit-first=i" => \$limit_first,
	   "limit-rows=i" => \$limit_rows,
	   "history|show" => \$history,
	   "summary:s" => \$summary,
	   "create" => \$create,
	   "keywords=s" => \@keywords,
	   "requestors=s" => \@requestors,
	   "cc=s" => \@cc,
	   "admincc=s" => \@admincc,
	   "status=s" => \@status,
	   "subject=s" => \$subject,
	   "owner=s" => \$owner,
	   "queue=s" => \$queue,
	   "time-left=i" => \$time_left,
	   "priority=i" => \$priority,
	   "final-priority=i" => \$final_priority,
	   "due=s" => \$due,
	   "starts=s" => \$starts,
	   "started=s" => \$started,
	   "contacted=s" => \$contacted,
	   "comment", \$comment,
	   "reply|respond", \$reply,
	   "source=s" => \$source,
	   "edit!" => \$edit,
	   "depends-on=s" => \@dependson,
	   "member-of=s" => \@memberof, 
	   "related-to=s" => \@relatedto,
	   "time-taken=i" => \$time_taken,
	   "verbose+" => \$verbose,
	   "debug" => \$debug,
	   "version" => \$version,
	   "help|h|usage" => \$help
	  );
  
# }}}


GetOptions(@args);

        print join(':',@keywords);
# {{{ If they want it, print a usage message and get out

if ($help) {
    print "This should be a usage message. it will be soon\n";
    exit(0);
}

# }}}

# {{{ Validate any options that were passed in. normalize them.




#if a queue was specified
if ($queue) {
    # make sure that $queue is a valid queue and load it into $queue_obj
}

#For each date in: $due, $starts, $started

# load up an RT::Date object and parse it into a normalized form
# if it can't parse it, log an error and null out the variable

# }}}

# {{{ Check if we're creating, if so, create the ticket and be done

if ($create) {
    debug("Creating a new ticket");

    #Make sure the current user can create tickets in this queue
    
    #Make sure that the owner specified can own tickets in this queue

    #see if we've specified an input file. if so, load it up

    #If we haven't specified no-edit, get up an editor session,
    #either with a temp file or the input file, if it exists.
    
    use RT::Ticket;
    my $Ticket=new RT::Ticket($CurrentUser);
    my ($ticket, $trans, $msg) =
      $Ticket->Create(Queue => $queue,
		    Owner => $owner,
		    Status => ,
		    Subject => $subject,
		    Requestors => ,
		    Cc => ,
		    AdminCc => ,
		    Due => $due,
		    Starts => $starts,
		    Started => $started,
		    TimeLeft => $time_left,
		    Priority => $priority,
		    FinalPriority => $final_priority,
		    Contacted =>,
		      
		   );
    print $msg . "\n";
}

# }}}

else {
    #Apply restrictions
    use RT::Tickets;
    my $Tickets = new RT::Tickets($CurrentUser);
    
    # {{{ Limit our search
    my $value; #to use when iterating through restrictions
    
    # {{{ limit on id
    if (@id) {
	foreach $value (@id) {
	    if ($value =~ /^\d+$/) {
		$Tickets->LimitId(
				 VALUE => "$value",
				 OPERATOR => '=');
	    }	
	}
    }	

    # }}}
    
    # {{{ limit on status
    if (@limit_status){
	foreach $value (@limit_status) {
	    if ($value =~ /^(.?)(new|open|stalled|resolved|dead)$/) {
		my $op = $1;
		my $val = $2;
		
		$op = ParseBooleanOp($op);
		$Tickets->LimitStatus(VALUE => "$val",
				      OPERATOR => "$op");
	    }	
	}
    }
    # }}}

    if (@limit_owner) {
	foreach $value (@limit_owner) {
	    if ($value =~ /^(\W?)(.*?)$/i) {
		my $op = $1;
		my $val = $2;
		
		$op = ParseBooleanOp($op);

		my $user_obj = new RT::User($RT::SystemUser);
		
		unless ($user_obj->Load($val)) {
		    debug("User '$val' not found");
		    return(-1);
		}
		$val = $user_obj->id();
		
		debug ("Limiting owner to $op $val");
		$Tickets->LimitOwner(VALUE => "$val",
				      OPERATOR => "$op");
	    }	
	}	
    }
    if (@limit_priority){
    }
    if (@limit_final_priority){
    }
    if (@limit_requestor){
    }
    if (@limit_subject){
    }
    if (@limit_body){
    }
    if (@limit_created){
    }
    if (@limit_due){
    }
    if (@limit_starts){
    }
    if (@limit_started){
    }
    if ($limit_first){
    }
    if ($limit_rows){
    }
# }}}
    
    # {{{ Iterate through all tickets we found

    my ($format, $titles, $code);
    
    #Set up the summary format if we need to
    if (defined $summary) {
	my $format_string = $summary || $ENV{'RT_SUMMARY_FORMAT'} || "%id4%subject20";
	debug ("Show ticket summary with format $format");

	($format, $titles, $code) = BuildListingFormat($format_string);
    }	
    printf $format ."\n", eval $titles;

    while (my $Ticket = $Tickets->Next()) {
	debug ("Now working on ticket ". $Ticket->id);
    
	#Run through all the ticket modifications we might want to do
	
	# {{{ deal with watchers
    
	# add / delete requestors
	foreach $value (@requestors) {
	    if ($value =~ /^(\W?)(.*)$/) {
		my $op = $1;
		my $addr = $2;
		
		$Ticket->AddRequestor(Email => $addr) if ($op eq '+');
		$Ticket->DeleteWatcher( $addr) if ($op eq '-');
	    }	
	}
	
	# add / delete ccs
	foreach $value (@cc) {
	    if ($value =~ /^(\W?)(.*)$/) {
		my $op = $1;
		my $addr = $2;
		
		$Ticket->AddCc(Email => $addr) if ($op eq '+');
		$Ticket->DeleteWatcher($addr) if ($op eq '-');
	    }	
	}	
	
	# add / delete adminccs
        debug("Looking at admin ccs");
	foreach $value (@admincc) {
	    if ($value =~ /^(\W?)(.*)$/) {
		my $op = $1;
		my $addr = $2;
		
		$Ticket->AddAdminCc(Email => $addr) if ($op eq '+');
		$Ticket->DeleteWatcher($addr) if ($op eq '-');
	    }	
	}	
	
	# }}}
	
	# {{{ Deal with ticket keywords

	my $KeywordSelects = $Ticket->QueueObj->KeywordSelects();
        debug ("Looking at keywords");
	foreach $value (@keywords) {
           debug("Looking at --keyword=$value");
	    if ($value =~ /^(\W?)(.*?)\/(.*)$/) {
		my $op = $1;
		my $select = $2;
		my $keyword = $3;
		
		debug("Going to $op Keyword $select / $keyword");	
		while (my $ks = $KeywordSelects->Next) {
                    debug("$select is select ".$ks->Name." is found");
		    next unless ($ks->Name =~ /$select/i);
		    debug ("Found a match for $select\n"); 
		    my $kids = $ks->KeywordObj->Descendents;
    
                    my ($kid);
		    foreach $kid (keys %{$kids}) {
                        debug("Now comparing $keyword with ".$kids->{$kid}. "\n");
			next unless ($kids->{$kid} =~ /^$keyword$/i);
		        debug("Going to $op $select / $keyword (".$kids->{$kid} .")");	
			$Ticket->DeleteKeyword(KeywordSelect => $ks->id,
					    Keyword => $kid) if ($op eq '-');
			
			$Ticket->AddKeyword(KeywordSelect => $ks->id,
					    Keyword => $kid) if ($op eq '+');
		    }
		    
		}
	    }
	}
	# }}}

	# {{{ deal with links

    # add /delete depends-ons
    
    # add /delete member-of

    # add / delete related-to
    
    # }}}
	
	# {{{ deal with dates

    #set due 
    
    #set starts

    #set started

    #set contacted
    
    # }}}
	
	# {{{ set other attributes
    
    #Set priority

    #Set final priority

    #Set status
    
    #Set time left
    
    #Set owner

    # }}}
	
	# {{{ Perform ticket comments/replies
    if ($reply) {
	debug("Replying to ticket ".$Ticket->Id);
	
	my @lines =GetMessageContent($edit, $source);
	
	#TODO build this entity
	my $MIMEObj = MIME::Entity->build();
	
	$Ticket->Correspond( MIMEObj => $MIMEObj,
			     TimeTaken => $time_taken);
    }	
    
    elsif ($comment) {
	debug("Commenting on ticket ".$Ticket->Id);
	my @lines =GetMessageContent($edit, $source);
	
	#TODO build this entity
	my $MIMEObj = MIME::Entity->build();
	
	$Ticket->Comment( MIMEObj => $MIMEObj,
			  TimeTaken => $time_taken);
    }
    
    # }}}
	# {{{ Display whatever we need to display
    # {{{ Display a full ticket listing and history
    if ($history) {
	#Display the history
	debug("Show history for ".$Ticket->id);
	
	if ($Ticket->CurrentUserHasRight("ShowTicket")) {
	    &ShowSummary($Ticket);
	    print "\n";
	    &ShowHistory($Ticket);
	}
	else {
	    print "You don't have permission to view that ticket.\n";
	}
    }	

    # }}}
    
    # {{{ Display a summary if we need to
    if (defined $summary) {
	debug ("Show ticket summary with format $format");
	
	printf $format."\n", eval $code;

    }	
	# }}}
    
    # }}}
	
    }
    # }}}
    
}


$RT::Handle->Disconnect();




# {{{ sub GetCurrentUser 
sub GetCurrentUser  {
    if (!$CurrentUser) {
	my $Gecos;
	
	require RT::CurrentUser;
        
	#Instantiate a user object
    	
	$Gecos=(getpwuid($<))[0];
	#If the current user is 0, then RT will assume that the User object
	#is that of the currentuser.
	$CurrentUser = new RT::CurrentUser();
	$CurrentUser->LoadByGecos($Gecos);
    
	if (!$CurrentUser->Id) {
	    $CurrentUser = $RT::Nobody;
	    return(0);
	}
    }
    return($CurrentUser);
}
# }}}

# {{{ sub GetMessageContent

=head2 GetMessageContent

Takes two arguments a source file and a boolean "edit".  If the source file is undef or "",
assumes an empty file.  Returns an edited file as an array of lines.

=cut

sub GetMessageContent {
    my $source = shift;
    my $edit = shift;
    
    my @lines;
    
    if ($source) {
	#Load the sourcefile
    }
    if ($edit) {
	#write to a tmpfile and launch $EDITOR || /bin/vi
    }	
    
    return(@lines);

}

# }}}

# {{{ sub debug
sub debug {
    my $val = shift;
    $RT::Logger->debug($val."\n");
    if ($debug) {
	print STDERR "$val\n";
    }
}
# }}}

# {{{ ParseBooleanOp
=head2 ParseBooleanOp

  Takes an option modifier. returns the apropriate SQL operator.
  If it's handed ! or -, returns !=.  Otherwise returns =.

=cut

sub ParseBooleanOp {
    
    my $op = shift;
    
    #so that !new limits to not new, etc
    if ($op =~ /^(\!|-)/) {
	$op = "!=";
    }
    else {
	$op = "=";
    }
    
    return($op);
}
# }}}

# {{{ sub ShowSummary 
sub ShowSummary  {
    my $Ticket = shift;


    print <<EOFORM;
Serial Number: @{[$Ticket->Id]}   Status:@{[$Ticket->Status]} Worked: @{[$Ticket->TimeWorked]} minutes  Queue:@{[$Ticket->QueueObj->QueueId]}
      Subject: @{[$Ticket->Subject]}
   Requestors: @{[$Ticket->RequestorsAsString]}
           Cc: @{[$Ticket->CcAsString]}
     Admin Cc: @{[$Ticket->AdminCcAsString]}
        Owner: @{[$Ticket->OwnerObj->UserId]}
     Priority: @{[$Ticket->Priority]} / @{[$Ticket->FinalPriority]}
          Due: @{[$Ticket->DueAsString]}
      Created: @{[$Ticket->CreatedAsString]} (@{[$Ticket->AgeAsString]})
 Last Contact: @{[$Ticket->ToldAsString]} (@{[$Ticket->LongSinceToldAsString]})
  Last Update: @{[$Ticket->LastUpdatedAsString]} by @{[$Ticket->LastUpdatedBy]}
	         
EOFORM

my $selects = $Ticket->QueueObj->KeywordSelects();
    #get the keyword selects
    print "Keywords:\n";
    while (my $select = $selects->Next) {
	print "\t" .$select->Name .": ";
	my $keys = $Ticket->KeywordsObj($select->id);	
	while (my $key = $keys->Next) {
	    print $key->KeywordObj->RelativePath($select->KeywordObj) . "  ";
	    
	}	
	print "\n";
    }
    
#iterate through the keyword selects.
#print the keyword select and all the related keywords




#TODO: better link descriptions
   while (my $l=$Ticket->Children->Next) {
       print $l->BaseObj->id," (",$l->BaseObj->Subject,") is  ",$l->Type," this ticket\n";
   }
   while (my $l=$Ticket->Parents->Next) {
       print "This ticket is ",$l->Type," ",$l->TargetObj->Id," (",$l->TargetObj->Subject,")\n";
   }
}
# }}}

# {{{ sub ShowHistory 
sub ShowHistory  {
    my $Ticket = shift;
    my $Transaction;    
    my $Transactions = $Ticket->Transactions;

    while ($Transaction = $Transactions->Next) {
      &ShowTransaction($Transaction);
    }   
  }
# }}}

# {{{ sub ShowTransaction 
sub ShowTransaction  {
  my $transaction = shift;
  
print <<EOFORM;
==========================================================================
Date: @{[$transaction->CreatedAsString]} (@{[$transaction->TimeTaken]} minutes)
@{[$transaction->Description]}
EOFORM
    ;
  my $attachments=$transaction->Attachments();
  while (my $message=$attachments->Next) {
    print <<EOFORM;
--------------------------------------------------------------------------
@{[$message->Headers]}
EOFORM

    if ($message->ContentType =~ m{^(text/plain|message)}) {
	print $message->Content;
    } else {
	print $message->ContentType, " not shown";
    }
  }
  print "\n";
  return();
}
# }}}


# {{{ sub BuildListingFormat
sub BuildListingFormat {
    my $format_string = shift;

    my ($id, @format, @code, @titles);
    my ($field,$titles,$length, $format);

    my $code = "";

    # {{{ attribs
    my $attribs = { id => { chars => '4',
			    justify => 'r',
			    title => 'id',
			    value => '$Ticket->id',
			  },
		
		    queue => { chars => '8',
			       justify => 'l',
			       title => 'Queue',
			       value => '$Ticket->QueueObj->id' 
			     },
		    subject => { chars => '30',
				 justify => 'l',
				 title => 'Subject',
				 value => '$Ticket->Subject',
			       },
		    priority => { chars => '2',
				  justify => 'r',
				  title => 'Pri',
				  value => '$Ticket->Priority',
				},
		    final_priority => {  chars => '2',
					 justify => 'r',
					 title => 'Fin',
					 value => '$Ticket->FinalPriority',
				      },
		    time_worked => { chars => '6',
				     justify => 'r',
				     title => 'Worked',
				     value => '$Ticket->TimeWorked',
				   },
		    time_left => { chars => '5',
				   justify => 'r',
				   title => 'Left',
				   value => '$Ticket->TimeLeft',
			       
				 },
		
		    status => {  chars => '6',
				 justify => 'r',
				 title => 'Status',
				 value => '$Ticket->Status',
			      },
		    owner => {  chars => '10',
				justify => 'r',
				title => 'Owner',
				value => '$Ticket->Owner'
			     },
		    requestor => {  chars => '10',
				    justify => 'r',
				    title => 'Requestor',
				    value => '$Ticket->RequestorsAsString'
				 },
		    created => {  chars => '12',
				  justify => 'r',
				  title => 'Created',
				  value => '$Ticket->CreatedAsString'
			       },
		    updated => {  chars => '12',
				  justify => 'r',
				  title => 'Updated',
				  value => '$Ticket->UpdatedAsString'
			       },
		    due => {  chars => '12',
			      justify => 'r',
			      title => 'Due',
			      value => '$Ticket->DueAsString'
			   },
		    told => {  chars => '12',
			       justify => 'r',
			       title => 'Told',
			       value => '$Ticket->ToldAsString'
			    },
		
		
		
		  };
    
    
    # }}}
    

    foreach $field (split ('%',$format_string)) {
	
	if ($field =~ /^(\D*?)(\d*?)$/) {
	    $id = $1;
	    $length = $2;
	}
	else {	
	    debug ("Error parsing $field\n");
	}
	if ($length) {
	    push (@format, "%".$length.".".$length."s ");
	    
	    push (@code,  $attribs->{"$id"}->{'value'});
		  
	    push (@titles, "'". $attribs->{"$id"}->{title}. "'");
	}
	
	
    }
    my $code ="";
    my $code = join (',', @code);
    my $format = join (" ", @format);
    my $titles = join (', ', @titles);
    
  
    return ($format, $titles, $code);
}
# }}}



1;

