#!!!PERL!! -w

# $Header$
# (c) 1996-2001 Jesse Vincent <jesse@fsck.com>
# This software is redistributable under the terms of the GNU GPL


package RT;
use strict;
use vars qw($VERSION $Handle $Nobody $SystemUser);

$VERSION="!!RT_VERSION!!";


use lib "!!RT_LIB_PATH!!";
use lib "!!RT_ETC_PATH!!";

use RT::Interface::Email  qw(CleanEnv LoadConfig DBConnect);

#Clean out all the nasties from the environment
CleanEnv();

#Load etc/config.pm and drop privs
LoadConfig();

#Connect to the database and get RT::SystemUser and RT::Nobody loaded
DBConnect();


use RT::Ticket;
use RT::Queue;
use MIME::Parser;
use File::Temp;
use Mail::Address;


#Set some sensible defaults 
my $Queue = 1;
my $time = time;
my $Action = "correspond";  

my ($Verbose, $ReturnTid, $Debug);
my ($From, $TicketId, $Subject,$SquelchReplies);
my ($status, $msg);

# {{{ parse commandline 

while (my $flag = shift @ARGV) {
    if (($flag eq '-v') or ($flag eq '--verbose')) {
	$Verbose = 1;
    }
    if (($flag eq '-t') or ($flag eq '--ticketid')) {
	$ReturnTid = 1;
    }
    
    if (($flag eq '-d') or ($flag eq '--debug')) {
	$RT::Logger->debug("Debug mode enabled\n");
	$Debug = 1;
      }
    
    if (($flag eq '-q') or ($flag eq '--queue')) {
	$Queue = shift @ARGV;
    } 
      if (($flag eq '-a') or ($flag eq '--action')) {
	  $Action = shift @ARGV;
      } 
    
    
}

# }}}

# get the current mime entity from stdin
my ($entity, $head) = ParseMIMEEntityFromSTDIN();

#Get us a current user object.
my $CurrentUser = GetCurrentUser($head);

#Get someone to send runtime errors to;
my $ErrorsTo = ParseErrorsToAddressFromHead($head);


my $MessageId = $head->get('Message-Id') || 
  "<no-message-id-".time.rand(2000)."\@.$RT::rtname>";

#Pull apart the subject line
$Subject = $head->get('Subject') || "[no subject]";
chomp $Subject;

# Get the ticket ID
$TicketId = ParseTicketId($Subject);

#Set up a queue object
my $QueueObj = RT::Queue->new($CurrentUser);
$QueueObj->Load($Queue);
unless ($QueueObj->id ) {

  MailError(To => $RT::OwnerEmail,
                  Subject => "RT Bounce: $Subject",
                  Explanation => "RT couldn't find the queue: $Queue",
                  MIMEObj => $entity);

}

# {{{ Lets check for mail loops of various sorts.

my $IsAutoGenerated = CheckForAutoGenerated($head);

my $IsSuspiciousSender = CheckForSuspiciousSender($head);

my $IsALoop = CheckForLoops($head);


#If the message is autogenerated, we need to know, so we can not 
# send mail to the sender
if ($IsSuspiciousSender || $IsAutoGenerated || $IsALoop) {
    $SquelchReplies = 1;
    
    #TODO: Is what we want to do here really 
    #  "Make the requestor cease to get mail from RT"?
    # This might wreak havoc with vacation-mailing users.
    # Maybe have a "disabled for bouncing" state that gets
    # turned off when we get a legit incoming message

}


# {{{ Warn someone  if it's a loop

# Warn someone if it's a loop, before we drop it on the ground
if ($IsALoop) {
    $RT::Logger->crit("RT Recieved mail ($MessageId) from itself.");
    
    #Should we mail it to RTOwner?
    if ($RT::LoopsToRTOwner) {
	MailError(To => $RT::OwnerEmail,
		  Subject => "RT Bounce: $Subject",
		  Explanation => "RT thinks this message may be a bounce",
		  MIMEObj => $entity);
	
	#Do we actually want to store it?
	exit unless ($RT::StoreLoops);
    }
}

# }}}


   #Don't let the user stuff the RT-Squelch-Replies-To header.
    if ($head->get('RT-Squelch-Replies-To')) {
        $head->add('RT-Relocated-Squelch-Replies-To',
                   $head->get('RT-Squelch-Replies-To'));
        $head->delete('RT-Squelch-Replies-To')
    }


if ($SquelchReplies) {
    ## TODO: This is a hack.  It should be some other way to
    ## indicate that the transaction should be "silent".

    my $Sender = ParseSenderAddressFromHead($head);
    $head->add('RT-Squelch-Replies-To', $Sender);
}

# }}}

# {{{ If we don't have a ticket Id, we're creating a new ticket

if (!defined($TicketId)) {
    
    #If the message doesn't reference a ticket #, create a new ticket
    
    # {{{ Create a new ticket
    if ($Action =~ /correspond/) {
	
	#    open a new ticket 
	my @Requestors = ($CurrentUser->id);
	
	my @Cc;
	if ($RT::ParseNewMessageForTicketCcs) {
		@Cc = ParseCcAddressesFromHead(Head => $head, QueueObj => $QueueObj );
	}

	my $Ticket = new RT::Ticket($CurrentUser);
	my ($id, $Transaction, $ErrStr) = 
	  $Ticket->Create ( Queue => $Queue,
			    Subject => $Subject,
			    Requestor => \@Requestors,
			    Cc => \@Cc,
			    MIMEObj => $entity
			  );
	if ($id == 0 ) {
	    MailError( To => $ErrorsTo,
 		       Subject => "Ticket creation failed",
		       Explanation => $ErrStr,
		       MIMEObj => $entity
		     );
	    $RT::Logger->error("Create failed: $id / $Transaction / $ErrStr ");
	}	
    }

    # }}}
    
    else {
	#TODO Return an error message
	MailError( To => $ErrorsTo,
		   Subject => "No ticket id specified",
		   Explanation => "$Action aliases require a TicketId to work on",
		   MIMEObj => $entity
		 );
	
	$RT::Logger->crit("$Action aliases require a TicketId to work on ".
			  "(from ".$CurrentUser->UserObj->EmailAddress.") ".
			  $MessageId);
	return();
    }
}

# }}}

# {{{ If we've got a ticket ID, update the ticket

else {
    
    #   If the action is comment, add a comment.
    if ($Action =~ /comment/i){
	
	my $Ticket = new RT::Ticket($CurrentUser);
	$Ticket->Load($TicketId);
	unless ($Ticket->Id) {
	    MailError( To => $ErrorsTo,
		       Subject => "Comment not recorded",
		       Explanation => "Could not find a ticket with id $TicketId",
		       MIMEObj => $entity
		     );
	    #Return an error message saying that Ticket "#foo" wasn't found.
	}
	
	($status, $msg) = $Ticket->Open;	# Reopening it, if necessary 
	
	($status, $msg) = $Ticket->Comment(MIMEObj=>$entity);
	unless ($status) {
	    #Warn the sender that we couldn't actually submit the comment.
	    MailError( To => $ErrorsTo,
		       Subject => "Comment not recorded",
		       Explanation => $msg,
		       MIMEObj => $entity
		     );
	}	
    }

    # If the message is correspondence, add it to the ticket
    elsif ($Action =~ /correspond/i) {
	my $Ticket = RT::Ticket->new($CurrentUser);
	$Ticket->Load($TicketId);
	$Ticket->Open;   #TODO: Don't open if it's alreadyopen
	
	#TODO: Check for error conditions
	($status, $msg) = $Ticket->Correspond(MIMEObj => $entity);
	unless ($status) {

	    #Return mail to the sender with an error
	    MailError( To => $ErrorsTo,
		       Subject => "Correspondence not recorded",
		       Explanation => $msg,
		       MIMEObj => $entity
		     );
	}
    }

    else {
	#Return mail to the sender with an error
	    MailError( To => $ErrorsTo,
		       Subject => "RT Configuration error",
		       Explanation => "'$Action' not a recognized action.".
		                      " Your RT administrator has misconfigured ".
		                      "the mail aliases which invoke RT" ,
		       MIMEObj => $entity
		     );

	$RT::Logger->crit("$Action type unknown for $MessageId");
	
    }
    
}

# }}}

$RT::Handle->Disconnect();


# Everything below this line is a helper sub. most of them will eventually
# move to Interface::Email

# {{{ Helper Subs

# {{{ sub CheckForLoops 

sub CheckForLoops  {
    my $head = shift;
    
    #If this instance of RT sent it our, we don't want to take it in
    my $RTLoop = $head->get("X-RT-Loop-Prevention") || "";
    if ($RTLoop eq "$RT::rtname") {
	return (1);
    }
    
    # TODO: We might not trap the case where RT instance A sends a mail
    # to RT instance B which sends a mail to ...
    return (undef);
}

# }}}

# {{{ sub CheckForSuspiciousSender

sub CheckForSuspiciousSender {
    my $head = shift;

    #if it's from a postmaster or mailer daemon, it's likely a bounce.
    
    #TODO: better algorithms needed here - there is no standards for
    #bounces, so it's very difficult to separate them from anything
    #else.  At the other hand, the Return-To address is only ment to be
    #used as an error channel, we might want to put up a separate
    #Return-To address which is treated differently.
    
    #TODO: search through the whole email and find the right Ticket ID.

    my ($From, $junk) = ParseSenderAddressFromHead($head);
    
    if (($From =~ /^mailer-daemon/i) or
	($From =~ /^postmaster/i)){
	return (1);
	
    }
    
    return (undef);

}

# }}}

# {{{ sub CheckForAutoGenerated
sub CheckForAutoGenerated {
    my $head = shift;
    
    my $Precedence = $head->get("Precedence") || "" ;
    if ($Precedence =~ /^(bulk|junk)/i) {
	return (1);
    }
    else {
	return (0);
    }
}

# }}}

# {{{ sub ParseMIMEEntityFromSTDIN

sub ParseMIMEEntityFromSTDIN {

    # Create a new parser object:
    
    my $parser = new MIME::Parser;
    
    # {{{ Config $parser to store large attacments in temp dir

    ## TODO: Does it make sense storing to disk at all?  After all, we
    ## need to put each msg as an in-core scalar before saving it to
    ## the database, don't we?

    ## At the same time, we should make sure that we nuke attachments 
    ## Over max size and return them

    ## TODO: Remove the temp dir when we don't need it any more.

    my $AttachmentDir = File::Temp::tempdir (TMPDIR => 1, CLEANUP => 1);
    
    # Set up output directory for files:
    $parser->output_dir("$AttachmentDir");
  
    #If someone includes a message, don't extract it
    $parser->extract_nested_messages(0);

   
    # Set up the prefix for files with auto-generated names:
    $parser->output_prefix("part");

    # If content length is <= 20000 bytes, store each msg as in-core scalar;
    # Else, write to a disk file (the default action):
  
    $parser->output_to_core(20000);

    # }}} (temporary directory)

    #Ok. now that we're set up, let's get the stdin.
    my $entity;
    unless ($entity = $parser->read(\*STDIN)) {
	die "couldn't parse MIME stream";
    }
    #Now we've got a parsed mime object. 
    
    # Get the head, a MIME::Head:
    my $head = $entity->head;
    
    # TODO - information about the charset is lost here!
    $head->decode;

    return ($entity, $head);

}
# }}}

# {{{ sub ParseTicketId 

sub ParseTicketId {
    my $Subject = shift;
    my ($Id);
    
    if ($Subject =~ s/\[$RT::rtname \#(\d+)\]//i) {
	$Id = $1;
	$RT::Logger->debug("Found a ticket ID. It's $Id");
	return($Id);
    }
    else {
	return(undef);
    }
}
# }}}

# {{{ sub MailError 
sub MailError {
    my %args = (To => $RT::OwnerEmail,
		Bcc => undef,
		From => $RT::CorrespondAddress,
		Subject => 'There has been an error',
		Explanation => 'Unexplained error',
		MIMEObj => undef,
		@_);

    $RT::Logger->crit($args{'Explanation'});
    my $entity = MIME::Entity->build( Type  =>"multipart/mixed",
				      From => $args{'From'},
				      Bcc => $args{'Bcc'},
				      To => $args{'To'},
				      Subject => $args{'Subject'},
				    );
    $entity->attach(  Data => $args{'Explanation'}."\n");
    
    my $mimeobj = $args{'MIMEObj'};
    $mimeobj->sync_headers();
    $entity->add_part($mimeobj);
    
    $entity->send($RT::MailCommand, $RT::MailParams);
        
}

# }}}

# {{{ sub GetCurrentUser 

sub GetCurrentUser  {
    my $head = shift;
    
    #Suck the address of the sender out of the header
    my ($Address, $Name) = ParseSenderAddressFromHead($head);
    
    #This will apply local address canonicalization rules
    $Address = RT::CanonicalizeAddress($Address);
  
    my $CurrentUser = RT::CurrentUser->new();
    
    $CurrentUser->LoadByEmail($Address);
  
    #If we can't get it by email address, try by name.  
    unless ($CurrentUser->Id) {
	$CurrentUser->LoadByName($Address);
    }
    

    unless ($CurrentUser->Id) {
	#If it fails, create a user
	
	
	my $NewUser = RT::User->new($RT::SystemUser);
	
	my ($Val, $Message) = 
	  $NewUser->Create(Name => $Address,
			   EmailAddress => $Address,
			   RealName => "$Name",
			   Password => undef,
			   Privileged => 0,
			   Comments => 'Autocreated on ticket submission'
			  );
	
	unless ($Val) {
	    $RT::Logger->crit("Create user failed in mailgateway: $Message\n");
	    #TODO this should not just up and die. 
	    # at the worst it should send mail.
	    MailError( To => $ErrorsTo,
		       Subject => "User could not be created",
		       Explanation => $Message,
		       MIMEObj => $entity
		     );
	}
	
	#Load the new user object
	$CurrentUser->LoadByEmail($Address);
	
	unless ($CurrentUser->id) {
		$RT::Logger->warn("Couldn't load user '$Address'.".
			          " Defaulting to nobody");

	$CurrentUser->Load($RT::Nobody->Id);
    }
    return ($CurrentUser);
}

# }}}

# {{{ ParseCcAddressesFromHead 

=head2 ParseCcAddressesFromHead HEAD

Takes a head object. Returns a list of all email addresses in the To and Cc headers
b<except> the current Queue\'s email addresses, the CurrentUser\'s email address 
and anything that the configuration sub RT::IsRTAddress matches.

=cut
  
sub ParseCcAddressesFromHead {
    my %args = ( Head => undef,
		 QueueObj => undef,
		 @_ );
    
    my (@Addresses);
        
    my @ToObjs = Mail::Address->parse($args{'Head'}->get('To'));
    my @CcObjs = Mail::Address->parse($args{'Head'}->get('Cc'));
    
    foreach my $AddrObj (@ToObjs, @CcObjs) {
	my $Address = $AddrObj->address;
	$Address = RT::CanonicalizeAddress($Address);
 	next if ($CurrentUser->EmailAddress =~ /^$Address$/i);
	next if ($args{'QueueObj'}->CorrespondAddress =~ /^$Address$/i);
	next if ($args{'QueueObj'}->CommentAddress =~ /^$Address$/i);
	next if (RT::IsRTAddress($Address));
	
	push (@Addresses, $Address);
    }
    return (@Addresses);
}


# }}}

# {{{ ParseSenderAdddressFromHead

=head2 ParseSenderAddressFromHead

Takes a MIME::Header object. Returns a tuple: (user@host, friendly name) 
of the From (evaluated in order of Reply-To:, From:, Sender)

=cut

sub ParseSenderAddressFromHead {
    my $head = shift;
    #Figure out who's sending this message.
    my $From = $head->get('Reply-To') || 
      $head->get('From') || 
	$head->get('Sender');
    return (ParseAddressFromHeader($From));
}
# }}}

# {{{ ParseErrorsToAdddressFromHead

=head2 ParseErrorsToAddressFromHead

Takes a MIME::Header object. Return a single value : user@host
of the From (evaluated in order of Errors-To:,Reply-To:, From:, Sender)

=cut

sub ParseErrorsToAddressFromHead {
    my $head = shift;
    #Figure out who's sending this message.
    my $From = $head->get('ErrorsTo') || $head->get('Reply-To') || 
      $head->get('From') || $head->get('Sender');
    my ($addr, $name ) = ParseAddressFromHeader($From);
    return ($addr);
}
# }}}

# {{{ ParseAddressFromHeader

=head2 ParseAddressFromHeader ADDRESS

Takes an address from $head->get('Line') and returns a tuple: user@host, friendly name

=cut


sub ParseAddressFromHeader{
    my $Addr = shift;

    
    #TODO: probably, we should do something smart here like generate
    # the ticket as "system"
    
    my @Addresses = Mail::Address->parse($Addr);
    
    my $AddrObj = $Addresses[0];
    my $Name =  ($AddrObj->phrase || $AddrObj->comment || $AddrObj->address);
    
    #Lets take the from and load a user object.
    my $Address = $AddrObj->address;

    return ($Address, $Name);
}
# }}}


#When we call die, trap it and log->crit with the value of the die.
$SIG{__DIE__}  = sub {
    unless ($^S || !defined $^S ) {
        $RT::Logger->crit("$_[0]");
	MailError( To => $ErrorsTo,  
		   Bcc => $RT::OwnerEmail,
		   Subject => "RT Critical error. Message not recorded!",
		   Explanation => "$_[0]",
		   MIMEObj => $entity
		 );
	exit(-1);
    }
    else {
        #Get out of here if we're in an eval
        die $_[0];
    }
};



1;
