#!/usr/bin/perl -w

# $Header$
# (c) 1996-2001 Jesse Vincent <jesse@fsck.com>
# This software is redistributable under the terms of the GNU GPL


package RT;
use strict;
use vars qw($VERSION $Handle $Nobody $SystemUser);

$VERSION="!!RT_VERSION!!";


use lib "!!RT_LIB_PATH!!";
use lib "!!RT_ETC_PATH!!";

use RT::Interface::Email  qw(CleanEnv LoadConfig DBConnect);

#Clean out all the nasties from the environment
CleanEnv();

#Load etc/config.pm and drop privs
LoadConfig();

#Connect to the database and get RT::SystemUser and RT::Nobody loaded
DBConnect();


use RT::Ticket;
use MIME::Parser;
use File::Temp;
use Mail::Address;


#Set some sensible defaults 
my $Queue = 1;
my $time = time;
my $Action = "correspond";  

my ($Verbose, $ReturnTid, $Debug);
my ($From, $TicketId, $Subject,$SquelchReplies);


# {{{ parse commandline 
while (my $flag = shift @ARGV) {
    if (($flag eq '-v') or ($flag eq '--verbose')) {
	$RT::Logger->debug('Verbose mode enabled\n');
	$Verbose = 1;
    }
    if (($flag eq '-t') or ($flag eq '--ticketid')) {
	$RT::Logger->debug('Return ticket id mode enabled\n');
	$ReturnTid = 1;
    }
    
    if (($flag eq '-d') or ($flag eq '--debug')) {
	$RT::Logger->debug("Debug mode enabled\n");
	$Debug = 1;
      }
    
    if (($flag eq '-q') or ($flag eq '--queue')) {
	$Queue = shift @ARGV;
	$RT::Logger->debug("Queue set to $Queue\n");
    } 
      if (($flag eq '-a') or ($flag eq '--action')) {
	  
	  $Action = shift @ARGV;
	  $RT::Logger->debug("Action set to $Action\n");
      } 
    
    
  }
# }}}

# get the current mime entity from stdin
my ($entity, $head) = ParseMIMEEntityFromSTDIN();

#Get us a current user object.
my $CurrentUser = &GetCurrentUser($head);

my $MessageId = $head->get('Message-Id') || 
  "<no-message-id-".time.rand(2000)."\@.$RT::rtname>";

#Pull apart the subject line
$Subject = $head->get('Subject') || "[no subject]";
chomp $Subject;

# Get the ticket ID
$TicketId = ParseTicketId($Subject);

# {{{ Lets check for mail loops of various sorts.

$RT::Logger->debug("Checking for mail loops\n");
my $IsAutoGenerated = &CheckForAutoGenerated($head);

my $IsSuspiciousSender = &CheckForSuspiciousSender($head);

my $IsALoop = &CheckForLoops($head);

$RT::Logger->debug("Done checking for mail loops\n");
#If the message is autogenerated, we need to know, so we can not 
# send mail to the sender
if ($IsSuspiciousSender || $IsAutoGenerated || $IsALoop) {
    $SquelchReplies = 1;
    
    #TODO: Is what we want to do here really 
    #  "Make the requestor cease to get mail from RT"?
    # This might wreak havoc with vacation-mailing users.
    # Maybe have a "disabled for bouncing" state that gets
    # turned off when we get a legit incoming message
    
    # Tobix: I don't think we should turn off watchers, I think we
    # should only stop _this_ transaction from generating emails.
    # A "silent transaction" mode - yeah, that was also a
    # suggested feature at RTCon.  That will be enough from
    # stopping loops.  
    # TODO: I also think it's important that it's
    # clearly written in the ticket history that this is a "silent
    # transaction"
}

#If it's actually a _local loop_ we want to warn someone
if ($IsALoop) {
    $RT::Logger->crit("RT Recieved mail ($MessageId) from itself");
    
    #Should we mail it to RTOwner?
    if ($RT::LoopsToRTOwner) {
	MailError(To => $RT::OwnerEmail,
		  Subject => "RT Bounce: $Subject",
		  Explanation => "RT thinks this message may be a bounce",
		  MIMEObj => $entity);
	
	
	## TODO: This return belongs to the outside of this
	## if-scope, and it has to be documented it in config.pm.
	## I think it makes sense to have it on as default, ref
	## [fsck #291]
	
	#Do we actually want to store it?
	return unless ($RT::StoreLoops);
    }
}

# }}}


if ($SquelchReplies) {
    ## TODO: This is a hack.  It should be some other way to
    ## indicate that the transaction should be "silent".

    $head->add('RT-Mailing-Loop-Alarm', 'True');
}

# {{{ If we don't have a ticket Id, we're creating a new ticket
if (!defined($TicketId)) {
    
    #If the message doesn't reference a ticket #, create a new ticket
    
    # {{{ Create a new ticket
	if ($Action =~ /correspond/) {
	    
	    #    open a new ticket 
	    $RT::Logger->debug("Now creating a new ticket\n");
	
	    my @Requestors = ($CurrentUser->id);
	 
	    my $Ticket = new RT::Ticket($CurrentUser);
	    my ($id, $Transaction, $ErrStr) = 
	      $Ticket->Create ( Queue => $Queue,
				Subject => $Subject,
				Requestor => \@Requestors,
				MIMEObj => $entity
			      );
	    if ($id == 0 )
	      {
		  #TODO +++ put in a new mimeobj with the error
		  MailError( To => $CurrentUser->EmailAddress, 
			     Subject => "Ticket creation failed",
			     Explanation => $ErrStr,
			     MIMEObj => $entity
			   );
		  
		  
		  $RT::Logger->debug("Create failed: $id / $Transaction / $ErrStr ");

	      }	
	}

	# }}}
    
    else {
	#TODO Return an error message
	$RT::Logger->crit("$Action aliases require a TicketId to work on ".
			  "(from ".$CurrentUser->UserObj->EmailAddress.") ".
			  $MessageId);
	return();
    }
}
# }}}

# {{{ If we've got a tickeet ID, update the ticket
else {

    #   If the action is comment, add a comment.
    if ($Action =~ /comment/i){
	$RT::Logger->debug("now commenting on ticket #".$TicketId."\n");

	my $Ticket = new RT::Ticket($CurrentUser);
	$Ticket->Load($TicketId) || die "Could not load ticket";

	$Ticket->Open;	# Reopening it, if necessary 

	# TODO: better error handling
	$Ticket->Comment(MIMEObj=>$entity);
    }

    # If the message is correspondence, add it to the ticket
    elsif ($Action =~ /correspond/i) {
	my $Ticket = RT::Ticket->new($CurrentUser);
	$Ticket->Load($TicketId);
	$Ticket->Open;   #TODO: Don't open if it's alreadyopen

	#TODO: Check for error conditions
	$Ticket->Correspond(MIMEObj => $entity);
    }

    elsif ($Action ne 'action') {
	$RT::Logger->crit("$Action type unknown for $MessageId");
    }

}
# }}}

#Parse commands in the headers or message boddy.
ParseCommands($entity);

$RT::Handle->Disconnect();

# Everything below this line is a helper sub. most of them will eventually
# move to Interface::Email again.

# {{{ sub CheckForLoops 
sub CheckForLoops  {
    my $head = shift;
    
    #If this instance of RT sent it our, we don't want to take it in
    my $RTLoop = $head->get("X-RT-Loop-Prevention") || "";
    if ($RTLoop eq "$RT::rtname") {
	return (1);
    }
    
    # TODO: We might not trap the case where RT instance A sends a mail
    # to RT instance B which sends a mail to ...
    return (undef);
}
# }}}

# {{{ sub CheckForSuspiciousSender
sub CheckForSuspiciousSender {
    my $head = shift;
    #if it's from a postmaster or mailer daemon, it's likely a bounce.
    
    #TODO: better algorithms needed here - there is no standards for
    #bounces, so it's very difficult to separate them from anything
    #else.  At the other hand, the Return-To address is only ment to be
    #used as an error channel, we might want to put up a separate
    #Return-To address which is treated differently.
    
    #TODO: search through the whole email and find the right Ticket ID.
    my $From = $head->get("From") || "";
    
    if (($From =~ /^mailer-daemon/i) or
	($From =~ /^postmaster/i)){
	return (1);
	
    }
    
    return (undef);

}
# }}}

# {{{ sub CheckForAutoGenerated
sub CheckForAutoGenerated {
    my $head = shift;
    
    my $Precedence = $head->get("Precedence") || "" ;
    if ($Precedence =~ /^(bulk|junk)/i) {
	return (1);
    }
    else {
	return (0);
    }
}

# }}}

# {{{ sub ParseMIMEEntityFromSTDIN

sub ParseMIMEEntityFromSTDIN {

    # Create a new parser object:
    
    my $parser = new MIME::Parser;
    
    # {{{ Config $parser to store large attacments in temp dir

    ## TODO: Does it make sense storing to disk at all?  After all, we
    ## need to put each msg as an in-core scalar before saving it to
    ## the database, don't we?

    ## At the same time, we should make sure that we nuke attachments 
    ## Over max size and return them

    ## TODO: Remove the temp dir when we don't need it any more.

    $RT::Logger->debug("Creating attachement temp dir\n");

    my $AttachmentDir = File::Temp::tempdir (TMPDIR => 1, CLEANUP => 1);
    
    # Set up output directory for files:
    $parser->output_dir("$AttachmentDir");
  
    #If someone includes a message, don't extract it
    $parser->extract_nested_messages(0);

   
    # Set up the prefix for files with auto-generated names:
    $parser->output_prefix("part");

    # If content length is <= 20000 bytes, store each msg as in-core scalar;
    # Else, write to a disk file (the default action):
  
    $parser->output_to_core(20000);

    # }}} (temporary directory)

    #Ok. now that we're set up, let's get the stdin.
    #TODO: Deal with this error better

    $RT::Logger->debug("Now reading the message from stdin\n");
    my $entity = $parser->read(\*STDIN) or die "couldn't parse MIME stream";
    
    #Now we've got a parsed mime object. 
        
    # Get the head, a MIME::Head:
    $head = $entity->head;
    
    # TODO - information about the charset is lost here!
    $head->decode;

    return ($entity, $head);

}
# }}}

# {{{ sub ParseTicketId 

sub ParseTicketId {
    my $Subject = shift;
    my ($Id);
    
    if ($Subject =~ s/\[$RT::rtname \#(\d+)\]//i) {
	$Id = $1;
	$RT::Logger->debug("Found a ticket ID. It's $Id");
	return($Id);
    }
    else {
	return(undef);
    }
}
# }}}

# {{{ sub ParseCommands

sub ParseCommands {
  my $entity = shift;

  my ($TicketId);
  # If the message contains commands, execute them
  
  # I'm allowing people to put in stuff in the mail headers here,
  # with the header key "RT-Command":
  
  my $commands=$entity->head->get('RT-Command');
  my @commands=(defined $commands ? ( ref $commands ? @$commands : $commands ) : ());
  
  # TODO: pull out "%RT " commands from the message body and put
  # them in commands
  
  # TODO: Handle all commands
  
  # TODO: The sender of the mail must be notificated about all %RT
  # commands that has been executed, as well as all %RT commands
  # that couldn't be processed.  I'll just use "die" for errors as
  # for now.
  
  for (@commands) {
      next if /^$/;
      chomp;
      $RT::Logger->info("Action requested through email: $_");
      my ($command, $arguments)=/^(?:\s*)((?:\w|-)+)(?: (.*))?$/
	or die "syntax error ($_)";
      if ($command =~ /^(Un)?[Ll]ink$/) {
	  if ($1) {
	      warn "Unlink not implemented yet: $_";
	      next;
	  }
	  my ($from, $typ, $to)=($arguments =~ m|^(.+?)(?:\s+)(\w+)(?:\s+)(.+?)$|)
	    or die "syntax error in link command ($arguments)";
	  my $dir='F';
	  # dirty? yes. how to fix?
	  $TicketId=RT::Link::_IsLocal(undef, $from);
	  if (!$TicketId) {
	      $dir='T';
	      $TicketId=RT::Link::_IsLocal(undef, $to);
	      warn $TicketId;
	  }
	  if (!$TicketId) {
	      die "Links require a base and a target ticket";
	  }
	  my $Ticket = new RT::Ticket($CurrentUser);
	  $Ticket->Load($TicketId) || die "Could not load ticket";
	  
	  #TODO: use a published interface.  +++
	  $Ticket->_NewLink(dir=>$dir,Target=>$to,Base=>$from,Type=>$typ);

      } else {
	  die "unknown command $command : $_";
      }
  }
}

# }}}

# {{{ sub MailError 
sub MailError {
    my %args = (To => $RT::OwnerEmail,
		From => $RT::CorrespondAddress,
		Subject => 'There has been an error',
		Explanation => 'Unexplained error',
		MIMEObj => undef,
		@_);

    $RT::Logger->crit($args{'Explanation'});
    my $entity = MIME::Entity->build( Type  =>"multipart/mixed",
				      From => $args{'From'},
				      To => $args{'To'},
				      Subject => $args{'Subject'},
				    );
    $entity->attach(  Data => $args{'Explanation'}."\n");
    
    my $mimeobj = $args{'MIMEObj'};
    $mimeobj->sync_headers();
    $entity->add_part($mimeobj);
    
    $entity->send($RT::MailCommand, $RT::MailParams);
        
}

# }}}

# {{{ sub GetCurrentUser 

sub GetCurrentUser  {
    my $head = shift;
    
    #Figure out who's sending this message.
    my $From = $head->get('Reply-To') || 
      $head->get('From') || 
	$head->get('Sender');
    
    #TODO: probably, we should do something smart here like generate
    # the ticket as "system"
    
    my @FromAddresses = Mail::Address->parse($From) 
      or die "Couldn't parse From-address";
    
    my $FromObj = $FromAddresses[0];
    my $Name =  ($FromObj->phrase || $FromObj->comment || $FromObj->address);
    
    #Lets take the from and load a user object.
    my $Address = $FromObj->address;
    
    #This will apply local address canonicalization rules

    $Address = RT::CanonicalizeAddress($Address);
  
    my $CurrentUser = RT::CurrentUser->new();
    
    $CurrentUser->LoadByEmail($Address);
    
    unless ($CurrentUser->Id) {
	#If it fails, create a user
	
	
	my $NewUser = RT::User->new($RT::SystemUser);
	
	my ($Val, $Message) = 
	  $NewUser->Create(Name => $Address,
			   EmailAddress => $Address,
			   RealName => "$Name",
			   Password => undef,
			   Privileged => 0,
			   Comments => 'Autocreated on ticket submission'
			  );
	
	if (!$Val) {
	    $RT::Logger->crit("Create user failed in mailgateway: $Message\n");
	    #TODO this should not just up and die. 
	    # at the worst it should send mail.
	    die $Message;
	}
	
	#Load the new user object
	$CurrentUser->LoadByEmail($Address);
    }
    return ($CurrentUser);
}

# }}}


1;

