#!!!PERL!! -w
# (c) 1996-2002 Jesse Vincent <jesse@bestpractical.com>
# This software is redistributable under the terms of the GNU GPL

=head1 TESTING

=begin testing

ok(open(GATE ,"| perl $RT::BinPath/rt-mailgate --action correspond --queue general"));
print GATE <<EOM;
From: hostmaster\@example.com
To: rt\@example.com
Subject: Sample message

blah
blah blah


EOM

ok(close(GATE), "Closed the pipe");

=end testing

=cut


use strict;

use lib "!!RT_LIB_PATH!!";

use RT;
use RT::Interface::Email  qw(CleanEnv  MailError);

#Clean out all the nasties from the environment
CleanEnv();

#Load etc/config.pm and drop privs
RT::LoadConfig();

#Connect to the database and get RT::SystemUser and RT::Nobody loaded
RT::Init();

#Drop setgid permissions
RT::DropSetGIDPermissions();

use RT::Ticket;
use RT::Queue;
use RT::EmailParser;
use MIME::Parser;
use File::Temp;
use Mail::Address;


#Set some sensible defaults 
my $Queue = 1;
my $time = time;
my $Action = "correspond";  

my ($Verbose, $ReturnTid, $Debug);
my ($From, $TicketId, $Subject,$SquelchReplies);

# using --owner-from-extension, this will let you set ticket owner on create
my $AssignTicketTo = undef;
my ($status, $msg);

# {{{ parse commandline 

while (my $flag = shift @ARGV) {
    if (($flag eq '-v') or ($flag eq '--verbose')) {
	$Verbose = 1;
    }
    if (($flag eq '-t') or ($flag eq '--ticketid')) {
	$ReturnTid = 1;
    }
    
    if (($flag eq '-d') or ($flag eq '--debug')) {
	$RT::Logger->debug("Debug mode enabled\n");
	$Debug = 1;
      }
    
    if (($flag eq '-q') or ($flag eq '--queue')) {
	$Queue = shift @ARGV;
    } 
    if ($flag eq '--ticket-id-from-extension') {
       $TicketId = $ENV{'EXTENSION'};
    }
    if ($flag eq '--queue-from-extension') {
       $Queue = $ENV{'EXTENSION'};
    }
    if ($flag eq '--owner-from-extension') {
        $AssignTicketTo = $ENV{'EXTENSION'};
    }

    if (($flag eq '-a') or ($flag eq '--action')) {
	  $Action = shift @ARGV;
    } 
    
    
}

# }}}
# get the current mime entity from stdin
my $message = RT::EmailParser->new($RT::Nobody);
my $retval = $message->ParseMIMEEntityFromSTDIN();
#TODO refactor this to handle errors

die unless $retval;


#Get someone to send runtime errors to;
my $ErrorsTo = $message->ParseErrorsToAddressFromHead();
$RT::Logger->debug("Errors to address is $ErrorsTo");
#Get us a current user object.
my $CurrentUser = $message->GetCurrentUser($ErrorsTo);

# We've already performed a warning and sent the mail off to somewhere safe ($RTOwner).
#  this is _exceedingly_ unlikely but we don't want to keep going if we don't have a current user

unless ($CurrentUser->Id) {
        $RT::Logger->crit("Couldn't find a user object for this message");
	exit(1);
}

my $MessageId = $message->Head->get('Message-Id') || "<no-message-id-".time.rand(2000)."\@.$RT::Organization>";

#Pull apart the subject line
$Subject = $message->Head->get('Subject') || "";
chomp $Subject;

# Get the ticket ID unless it's already set
$TicketId = $message->ParseTicketId($Subject) unless ($TicketId);

#Set up a queue object
my $QueueObj = RT::Queue->new($CurrentUser);
$QueueObj->Load($Queue);
unless ($QueueObj->id ) {
  MailError(To => $RT::OwnerEmail,
                  Subject => $CurrentUser->loc("RT Bounce: [_1]", $Subject),
                  Explanation => $CurrentUser->loc("RT couldn't find the queue: [_1]", $Queue),
                  MIMEObj => $message->Entity);

}

# {{{ Lets check for mail loops of various sorts.

my $IsAutoGenerated = $message->CheckForAutoGenerated();

my $IsSuspiciousSender = $message->CheckForSuspiciousSender();

my $IsALoop = $message->CheckForLoops();


#If the message is autogenerated, we need to know, so we can not 
# send mail to the sender
if ($IsSuspiciousSender || $IsAutoGenerated || $IsALoop) {
    $SquelchReplies = 1;

    $ErrorsTo = $RT::OwnerEmail;
    
    #TODO: Is what we want to do here really 
    #  "Make the requestor cease to get mail from RT"?
    # This might wreak havoc with vacation-mailing users.
    # Maybe have a "disabled for bouncing" state that gets
    # turned off when we get a legit incoming message

}


# {{{ Warn someone  if it's a loop

# Warn someone if it's a loop, before we drop it on the ground
if ($IsALoop) {
    $RT::Logger->crit("RT Received mail ($MessageId) from itself.");
    
    #Should we mail it to RTOwner?
    if ($RT::LoopsToRTOwner) {
	MailError(To => $RT::OwnerEmail,
		  Subject => $CurrentUser->loc("RT Bounce: [_1]", $Subject),
		  Explanation => $CurrentUser->loc("RT thinks this message may be a bounce"),
		  MIMEObj => message->Entity);
	
	#Do we actually want to store it?
	exit unless ($RT::StoreLoops);
    }
}

# }}}


   #Don't let the user stuff the RT-Squelch-Replies-To header.
    if ($message->Head->get('RT-Squelch-Replies-To')) {
        $message->Head->add('RT-Relocated-Squelch-Replies-To',
                   $message->Head->get('RT-Squelch-Replies-To'));
        $message->Head->delete('RT-Squelch-Replies-To')
    }


if ($SquelchReplies) {
    ## TODO: This is a hack.  It should be some other way to
    ## indicate that the transaction should be "silent".

    my ($Sender, $junk) = $message->ParseSenderAddressFromHead();
    $message->Head->add('RT-Squelch-Replies-To', $Sender);
}

# }}}


# {{{ If we require that the sender be found in an external DB and they're not
# forward this message to RTOwner


if ($RT::LookupSenderInExternalDatabase && 
    $RT::SenderMustExistInExternalDatabase )  {

    MailError(To => $RT::OwnerEmail,
	      Subject => $CurrentUser->loc("RT Bounce: [_1]", $Subject),
	      Explanation => $CurrentUser->loc("RT couldn't find requestor via its external database lookup"),
	      MIMEObj => $message->Entity);
    
}

# }}}

# {{{ elsif we don't have a ticket Id, we're creating a new ticket



elsif (!defined($TicketId)) {
    
    # {{{ Create a new ticket
    if ($Action =~ /correspond/) {
	
	#    open a new ticket 
	my @Requestors = ($CurrentUser->id);
	
	my @Cc;
	if ($RT::ParseNewMessageForTicketCcs) {
		@Cc =$message->ParseCcAddressesFromHead(
					CurrentUser => $CurrentUser,
					QueueObj => $QueueObj );
	}

	my $Ticket = RT::Ticket->new($CurrentUser);
	my ($id, $Transaction, $ErrStr) = 
	  $Ticket->Create ( Queue => $Queue,
			    Subject => $Subject,
                            Owner => $AssignTicketTo,
			    Requestor => \@Requestors,
			    Cc => \@Cc,
			    MIMEObj => $message->Entity
			  );
	if ($id == 0 ) {
	    MailError( To => $ErrorsTo,
 		       Subject => $CurrentUser->loc("Ticket creation failed"),
		       Explanation => $ErrStr,
		       MIMEObj => $message->Entity
		     );
	    $RT::Logger->error("Create failed: $id, $Transaction, $ErrStr");
	}	
    }

    # }}}
    
    else {
	#TODO Return an error message
	MailError( To => $ErrorsTo,
		   Subject => $CurrentUser->loc("No ticket id specified"),
		   Explanation => $CurrentUser->loc("[_1] aliases require a TicketId to work on", $Action),
		   MIMEObj => $message->Entity
		 );
	
	$RT::Logger->crit($Action." aliases require a TicketId to work on ".
			  "(from ".$CurrentUser->UserObj->EmailAddress.") ".
			  $MessageId);
    }
}

# }}}

# {{{ If we've got a ticket ID, update the ticket

else {
    
    #   If the action is comment, add a comment.
    if ($Action =~ /comment/i){
	
	my $Ticket = RT::Ticket->new($CurrentUser);
	$Ticket->Load($TicketId);
	unless ($Ticket->Id) {
	    MailError( To => $ErrorsTo,
		       Subject => $CurrentUser->loc("Comment not recorded"),
		       Explanation => $CurrentUser->loc("Could not find a ticket with id [_1]", $TicketId),
		       MIMEObj => $message->Entity
		     );
	    #Return an error message saying that Ticket "#foo" wasn't found.
	}
	
	($status, $msg) = $Ticket->Comment(MIMEObj=>$message->Entity);
	unless ($status) {
	    #Warn the sender that we couldn't actually submit the comment.
	    MailError( To => $ErrorsTo,
		       Subject => $CurrentUser->loc("Comment not recorded"),
		       Explanation => $msg,
		       MIMEObj => $message->Entity
		     );
	}	
    }

    # If the message is correspondence, add it to the ticket
    elsif ($Action =~ /correspond/i) {
	my $Ticket = RT::Ticket->new($CurrentUser);
	$Ticket->Load($TicketId);
	
	#TODO: Check for error conditions
	($status, $msg) = $Ticket->Correspond(MIMEObj => $message->Entity);
	unless ($status) {

	    #Return mail to the sender with an error
	    MailError( To => $ErrorsTo,
		       Subject => $CurrentUser->loc("Correspondence not recorded"),
		       Explanation => $msg,
		       MIMEObj => $message->Entity
		     );
	}
    }

    else {
	#Return mail to the sender with an error
	    MailError( To => $ErrorsTo,
		       Subject => $CurrentUser->loc("RT Configuration error"),
		       Explanation => $CurrentUser->loc("'[_1]' not a recognized action. ", $Action).
		                      $CurrentUser->loc("Your RT administrator has misconfigured the mail aliases which invoke RT"),
		       MIMEObj => $message->Entity
		     );

	$RT::Logger->crit(loc("[_1] type unknown for $MessageId", $Action));
	
    }
    
}

# }}}

$RT::Handle->Disconnect();


# Everything below this line is a helper sub. most of them will eventually
# move to Interface::Email

#When we call die, trap it and log->crit with the value of the die.
$SIG{__DIE__}  = sub {
    unless ($^S || !defined $^S ) {
        $RT::Logger->crit("$_[0]");
	MailError( To => $ErrorsTo,  
		   Bcc => $RT::OwnerEmail,
		   Subject => $CurrentUser->loc("RT Critical error. Message not recorded!"),
		   Explanation => "$_[0]",
		   MIMEObj => $message->Entity
		 );
	exit(-1);
    }
    else {
        #Get out of here if we're in an eval
        die $_[0];
    }
};



1;
