#!@PERL@
use Getopt::Long;
use LWP::UserAgent;

use constant EX_TEMPFAIL => 75;

my %opts;
GetOptions( \%opts, "queue=s", "action=s", "url=s", "username=s", "password=s",
            "jar=s", "help" );

if ( $opts{help} ) {
    require Pod::Usage;
    import Pod::Usage;
    pod2usage("RT Mail Gateway\n");
    exit 1;    # Don't want to succeed if this is really an email!
}

for (qw(username password url)) {
    die "RT misconfigured!\n\nNo $_ provided to mail gateway!\n"
      unless $opts{$_};
}

undef $/;
my $message = <>;
my $ua      = LWP::UserAgent->new();
$ua->cookie_jar( { file => $opts{jar} } );

my %args = (
    queue   => $opts{queue},
    action  => $opts{action},
    message => [ undef, "message", Content => $message ],
    SessionType => 'REST',    # Surpress login box
);

# Set up cookie here.

my $r = $ua->post( $opts{url} . "/REST/mail-gateway", {%args} );
check_failure($r);

my $content = $r->content;
if ( $content =~ /Not logged in/i ) {

    # Cookie wasn't OK, try again with u/p
    @args{qw(user pass)} = @opts{qw(username password)};

    $r = $ua->post( $opts{url} . "/REST/mail-gateway", {%args} );
    check_failure($r);
    $content = $r->content;
    if ( $content =~ /Not logged in/i ) {    # No joy at all
        die <<EOF;
Invalid credentials

The administrator of this RT instance failed to set up the credentials
for the mail gateway correctly.
EOF
    }
}

if ( $content !~ /ok/ ) {

    # This also catches "not ok". This is deliberate. It's not the
    # server's fault if the mail is bogus. We just want to know that
    # *something* came out of the server.
    die <<EOF
RT server error. 

The RT server which handled your email did not behave as expected. It
said:

$content
EOF
}

sub check_failure {
    my $r = shift;
    return if $r->is_success();

    # This ordinarily oughtn't to be able to happen, suggests a bug in RT.
    # So only load these heavy modules when they're needed.
    require HTML::TreeBuilder;
    require HTML::FormatText;

    my $error = $r->error_as_HTML;
    my $tree  = HTML::TreeBuilder->new->parse($error);
    $tree->eof;

    # It'll be a cold day in hell before RT sends out bounces in HTML
    my $formatter = HTML::FormatText->new( leftmargin  => 0,
                                           rightmargin => 50 );
    warn $formatter->format($tree);
    exit EX_TEMPFAIL;
}

=head1 NAME

rt-mailgate - Mail interface to RT3.

=head1 SYNOPSIS

    rt-mailgate --help : this text

Usual invocation (from MTA):

    rt-mailgate --action (correspond|comment) --queue queuename 
                --url http://your.rt.server/ --username mailgate 
                --password quux --jar /tmp/mailgate/cookies.txt

See C<man rt-mailgate> for more.

=head1 OPTIONS

=over 3

=item C<--action>    

Specifies whether this is a correspondence or comment address.

=item C<--queue>

Reflects which queue this address handles.

=item C<--url>

The location of the web server for your RT instance.

=item C<--username>

The user name the mail gateway runs as.

=item C<--password>

The mail gateway user's password.

=item C<--jar>

File in which to save RT cookie. If this is given and contains a valid
cookie, C<rt-mailgate> will present this to the web server instead of
the username and password. If this is given and doesn't contain a valid
cookie, the mailgate will log in and store the cookie for next time.

=head1 DESCRIPTION

The RT mail gateway is the primary mechanism for communicating with RT
via email. This program simply directs the email to the RT web server,
which handles filing correspondence and sending out any required mail.
It is designed to be run as part of the mail delivery process, either
called directly by the MTA or C<procmail>, or in a F<.forward> or
equivalent.

=head1 SETUP

Much of the set up of the mail gateway depends on your MTA and mail
routing configuration. However, you will need first of all to create an
RT user for the mail gateway and assign it a password; this helps to
ensure that mail coming into the web server did originate from the
gateway.

Next, you need to route mail to C<rt-mailgate> for the queues you're
monitoring. For instance, if you're using F</etc/aliases> and you have a
"bugs" queue, you will want something like this:

    bugs:         "|/opt/rt3/bin/rt-mailgate --queue bugs --action correspond
              --url http://rt.mycorp.com/ --user mailgate --password Quux"

    bugs-comment: "|/opt/rt3/bin/rt-mailgate --queue bugs --action comment
              --url http://rt.mycorp.com/ --user mailgate --password Quux"

Note that you don't have to run your RT server on your mail server, as
the mail gateway will happily relay to a different machine.

=head1 CUSTOMIZATION

By default, the mail gateway will accept mail from anyone. However,
there are situations in which you will want to authenticate users
before allowing them to communicate with the system. You can do this
via a plug-in mechanism in the RT configuration.

You can set the array C<@RT::MailPlugins> to be a list of plugins. The
default plugin, if this is not given, is C<Auth::MailFrom> - that is,
authentication of the person is done based on the C<From> header of the
email. If you have additional filters or authentication mechanisms, you
can list them here and they will be called in order:

    @RT::MailPlugins = (
        "Filter::SpamAssassin",
        "Auth::LDAP",
        # ...
    );

See the documentation for any additional plugins you have.

You may also put Perl subroutines into the C<@RT::MailPlugins> array, if
they behave as described below.

=head1 WRITING PLUGINS

What's actually going on in the above is that C<@RT::MailPlugins> is a
list of Perl modules; RT prepends C<RT::Interface::Email::> to the name,
to form a package name, and then C<use>'s this module. The module is
expected to provide a C<GetCurrentUser> subroutine, which takes three
parameters: a C<MIME::Entity> object representing the email, and the
C<RT::CurrentUser> object and authentication level returned from the
previous plugin.

It returns two values, the new C<RT::CurrentUser> object, and the new
authentication level. The authentication level can be zero, not allowed
to communicate with RT at all, (a "permission denied" error is mailed to
the correspondent) or one, which is the normal mode of operation.
Additionally, if C<-1> is returned, then the processing of the plug-ins
stops immediately and the message is ignored. 

=cut

