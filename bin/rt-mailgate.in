#!@PERL@ -w
# BEGIN LICENSE BLOCK
# 
# Copyright (c) 1996-2002 Jesse Vincent <jesse@bestpractical.com>
# 
# (Except where explictly superceded by other copyright notices)
# 
# This work is made available to you under the terms of Version 2 of
# the GNU General Public License. A copy of that license should have
# been provided with this software, but in any event can be snarfed
# from www.gnu.org
# 
# This work is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# 
# Unless otherwise specified, all modifications, corrections or
# extensions to this work which alter its source code become the
# property of Best Practical Solutions, LLC when submitted for
# inclusion in the work.
# 
# 
# END LICENSE BLOCK

use strict;
use Getopt::Long;
use LWP::UserAgent;

use constant EX_TEMPFAIL => 75;

my %opts;
GetOptions( \%opts, "queue=s", "action=s", "url=s", "jar=s", "help", "debug" );

if ( $opts{help} ) {
    require Pod::Usage;
    import Pod::Usage;
    pod2usage("RT Mail Gateway\n");
    exit 1;    # Don't want to succeed if this is really an email!
}

for (qw(url)) {
    die "$0 invoked improperly\n\nNo $_ provided to mail gateway!\n" unless $opts{$_};
}

undef $/;
my $message = <>;
my $ua      = LWP::UserAgent->new();
$ua->cookie_jar( { file => $opts{jar} } );

my %args = (
    queue   => $opts{queue},
    action  => $opts{action},
    message => $message,
    SessionType => 'REST',    # Surpress login box
);

# Set up cookie here.

my $full_url = $opts{'url'}. "/REST/1.0/NoAuth/mail-gateway";
warn "Connecting to $full_url" if $opts{'debug'};



my $r = $ua->post( $full_url, {%args} );
check_failure($r);

my $content = $r->content;
warn $content if ($opts{debug});

if ( $content !~ /^(ok|not ok)/ ) {

    # It's not the server's fault if the mail is bogus. We just want to know that
    # *something* came out of the server.
    die <<EOF
RT server error. 

The RT server which handled your email did not behave as expected. It
said:

$content
EOF

} 

sub check_failure {
    my $r = shift;
    return if $r->is_success();

    # This ordinarily oughtn't to be able to happen, suggests a bug in RT.
    # So only load these heavy modules when they're needed.
    require HTML::TreeBuilder;
    require HTML::FormatText;

    my $error = $r->error_as_HTML;
    my $tree  = HTML::TreeBuilder->new->parse($error);
    $tree->eof;

    # It'll be a cold day in hell before RT sends out bounces in HTML
    my $formatter = HTML::FormatText->new( leftmargin  => 0,
                                           rightmargin => 50 );
    warn $formatter->format($tree);
    warn "This is $0 exiting because of an undefined server error" if ($opts{debug});
    exit EX_TEMPFAIL;
}

=head1 NAME

rt-mailgate - Mail interface to RT3.

=head1 SYNOPSIS

    rt-mailgate --help : this text

Usual invocation (from MTA):

    rt-mailgate --action (correspond|comment) --queue queuename 
                --url http://your.rt.server/ 
                [--jar /tmp/mailgate/cookies.txt]

See C<man rt-mailgate> for more.

=head1 OPTIONS

=over 3

=item C<--action>    

Specifies whether this is a correspondence or comment address.

=item C<--queue>

Reflects which queue this address handles.

=item C<--url>

The location of the web server for your RT instance.


=item C<--jar>  OPTIONAL

File in which to save RT cookie. If this is given and contains a valid
cookie, C<rt-mailgate> will present this to the web server instead of
the username and password. If this is given and doesn't contain a valid
cookie, the mailgate will log in and store the cookie for next time.

=head1 DESCRIPTION

The RT mail gateway is the primary mechanism for communicating with RT
via email. This program simply directs the email to the RT web server,
which handles filing correspondence and sending out any required mail.
It is designed to be run as part of the mail delivery process, either
called directly by the MTA or C<procmail>, or in a F<.forward> or
equivalent.

=head1 SETUP

Much of the set up of the mail gateway depends on your MTA and mail
routing configuration. However, you will need first of all to create an
RT user for the mail gateway and assign it a password; this helps to
ensure that mail coming into the web server did originate from the
gateway.

Next, you need to route mail to C<rt-mailgate> for the queues you're
monitoring. For instance, if you're using F</etc/aliases> and you have a
"bugs" queue, you will want something like this:

    bugs:         "|/opt/rt3/bin/rt-mailgate --queue bugs --action correspond
              --url http://rt.mycorp.com/"

    bugs-comment: "|/opt/rt3/bin/rt-mailgate --queue bugs --action comment
              --url http://rt.mycorp.com/"

Note that you don't have to run your RT server on your mail server, as
the mail gateway will happily relay to a different machine.

=head1 CUSTOMIZATION

By default, the mail gateway will accept mail from anyone. However,
there are situations in which you will want to authenticate users
before allowing them to communicate with the system. You can do this
via a plug-in mechanism in the RT configuration.

You can set the array C<@RT::MailPlugins> to be a list of plugins. The
default plugin, if this is not given, is C<Auth::MailFrom> - that is,
authentication of the person is done based on the C<From> header of the
email. If you have additional filters or authentication mechanisms, you
can list them here and they will be called in order:

    @RT::MailPlugins = (
        "Filter::SpamAssassin",
        "Auth::LDAP",
        # ...
    );

See the documentation for any additional plugins you have.

You may also put Perl subroutines into the C<@RT::MailPlugins> array, if
they behave as described below.

=head1 WRITING PLUGINS

What's actually going on in the above is that C<@RT::MailPlugins> is a
list of Perl modules; RT prepends C<RT::Interface::Email::> to the name,
to form a package name, and then C<use>'s this module. The module is
expected to provide a C<GetCurrentUser> subroutine, which takes three
parameters: a C<MIME::Entity> object representing the email, and the
C<RT::CurrentUser> object and authentication level returned from the
previous plugin.

It returns two values, the new C<RT::CurrentUser> object, and the new
authentication level. The authentication level can be zero, not allowed
to communicate with RT at all, (a "permission denied" error is mailed to
the correspondent) or one, which is the normal mode of operation.
Additionally, if C<-1> is returned, then the processing of the plug-ins
stops immediately and the message is ignored. 

=cut

