#!@PERL@ -w
# BEGIN LICENSE BLOCK
# 
# Copyright (c) 1996-2002 Jesse Vincent <jesse@bestpractical.com>
# 
# (Except where explictly superceded by other copyright notices)
# 
# This work is made available to you under the terms of Version 2 of
# the GNU General Public License. A copy of that license should have
# been provided with this software, but in any event can be snarfed
# from www.gnu.org
# 
# This work is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# 
# Unless otherwise specified, all modifications, corrections or
# extensions to this work which alter its source code become the
# property of Best Practical Solutions, LLC when submitted for
# inclusion in the work.
# 
# 
# END LICENSE BLOCK

=head1 NAME

rt-mailgate - Mail interface to RT3.

=begin testing

ok(open(MAIL, "|@RT_BIN_PATH@/rt-mailgate --url http://localhost/ --queue general --action correspond"), "Opened the mailgate - $@");
print MAIL <<EOF;
From: root\@localhost
To: rt\@fsck.com
Subject: This is a test of new ticket creation

Blah!
Foob!
EOF
close (MAIL);

use RT::Tickets;
my $tickets = RT::Tickets->new($RT::SystemUser);
$tickets->OrderBy(FIELD => 'id', ORDER => 'DESC');
$tickets->Limit(FIELD => 'id', OPERATOR => '>', VALUE => '0');
my $tick = $tickets->First();
ok ($tick->Id, "found ticket ".$tick->Id);
ok ($tick->Subject eq 'This is a test of new ticket creation', "Created the ticket");





ok(open(MAIL, "|@RT_BIN_PATH@/rt-mailgate --url http://localhost/ --queue general --action correspond"), "Opened the mailgate - $@");
print MAIL <<EOF;
From: doesnotexist\@fsck.com
To: rt\@fsck.com
Subject: This is a test of new ticket creation as an unknown user

Blah!
Foob!
EOF
close (MAIL);

$tickets = RT::Tickets->new($RT::SystemUser);
$tickets->OrderBy(FIELD => 'id', ORDER => 'DESC');
$tickets->Limit(FIELD => 'id' ,OPERATOR => '>', VALUE => '0');
my $tick = $tickets->First();
ok ($tick->Id, "found ticket ".$tick->Id);
ok ($tick->Subject ne 'This is a test of new ticket creation as an unknown user', "failed to create the new ticket from an unprivileged account");
my $u = RT::User->new($RT::SystemUser);
$u->Load('doesnotexist@fsck.com');
ok( $u->Id == 0, " user does not exist and was not created by failed ticket submission");


my $g = RT::Group->new($RT::SystemUser);
$g->LoadSystemInternalGroup('Everyone');
ok( $g->Id, "Found 'everybody'");

my ($val,$msg) = $g->PrincipalObj->GrantRight(Right => 'CreateTicket');
ok ($val, "Granted everybody the right to create tickets - $msg");

sleep(60); # gotta sleep so the remote process' ACL cache times out

ok(open(MAIL, "|@RT_BIN_PATH@/rt-mailgate --url http://localhost/ --queue general --action correspond"), "Opened the mailgate - $@");
print MAIL <<EOF;
From: doesnotexist\@fsck.com
To: rt\@fsck.com
Subject: This is a test of new ticket creation as an unknown user

Blah!
Foob!
EOF
close (MAIL);

$tickets = RT::Tickets->new($RT::SystemUser);
$tickets->OrderBy(FIELD => 'id', ORDER => 'DESC');
$tickets->Limit(FIELD => 'id' ,OPERATOR => '>', VALUE => '0');
my $tick = $tickets->First();
ok ($tick->Id, "found ticket ".$tick->Id);
ok ($tick->Subject eq 'This is a test of new ticket creation as an unknown user', "failed to create the new ticket from an unprivileged account");
my $u = RT::User->new($RT::SystemUser);
$u->Load('doesnotexist@fsck.com');
ok( $u->Id != 0, " user does not exist and was not created by failed ticket submission");

($val,$msg) = $g->PrincipalObj->RevokeRight(Right => 'CreateTicket');
ok ($val, $msg);



=end testing

=cut


use strict;
use Getopt::Long;
use LWP::UserAgent;

use constant EX_TEMPFAIL => 75;

my %opts;
GetOptions( \%opts, "queue=s", "action=s", "url=s", "jar=s", "help", "debug", "extension=s" );

if ( $opts{help} ) {
    require Pod::Usage;
    import Pod::Usage;
    pod2usage("RT Mail Gateway\n");
    exit 1;    # Don't want to succeed if this is really an email!
}

for (qw(url)) {
    die "$0 invoked improperly\n\nNo $_ provided to mail gateway!\n" unless $opts{$_};
}

undef $/;
my $message = <>;
my $ua      = LWP::UserAgent->new();
$ua->cookie_jar( { file => $opts{jar} } );

my %args = (
    queue   => $opts{queue},
    action  => $opts{action},
    message => $message,
    SessionType => 'REST',    # Surpress login box
);


if ($opts{'extension'}) {
        $args{$opts{'extension'}} = $ENV{'EXTENSION'};
}

# Set up cookie here.

my $full_url = $opts{'url'}. "/REST/1.0/NoAuth/mail-gateway";
warn "Connecting to $full_url" if $opts{'debug'};



my $r = $ua->post( $full_url, {%args} );
check_failure($r);

my $content = $r->content;
warn $content if ($opts{debug});

if ( $content !~ /^(ok|not ok)/ ) {

    # It's not the server's fault if the mail is bogus. We just want to know that
    # *something* came out of the server.
    die <<EOF
RT server error. 

The RT server which handled your email did not behave as expected. It
said:

$content
EOF

} 

sub check_failure {
    my $r = shift;
    return if $r->is_success();

    # This ordinarily oughtn't to be able to happen, suggests a bug in RT.
    # So only load these heavy modules when they're needed.
    require HTML::TreeBuilder;
    require HTML::FormatText;

    my $error = $r->error_as_HTML;
    my $tree  = HTML::TreeBuilder->new->parse($error);
    $tree->eof;

    # It'll be a cold day in hell before RT sends out bounces in HTML
    my $formatter = HTML::FormatText->new( leftmargin  => 0,
                                           rightmargin => 50 );
    warn $formatter->format($tree);
    warn "This is $0 exiting because of an undefined server error" if ($opts{debug});
    exit EX_TEMPFAIL;
}


=head1 SYNOPSIS

    rt-mailgate --help : this text

Usual invocation (from MTA):

    rt-mailgate --action (correspond|comment) --queue queuename 
                --url http://your.rt.server/ 
                [ --extension (queue|action|ticket)

See C<man rt-mailgate> for more.

=head1 OPTIONS

=over 3

=item C<--action>    

Specifies whether this is a correspondence or comment address.

=item C<--queue>

Reflects which queue this address handles.

=item C<--url>

The location of the web server for your RT instance.


=item C<--extension> OPTIONAL

Some MTAs will route mail sent to user-foo@host or user+foo@host to user@host
and present "foo" in the environment variable $EXTENSION. By specifying
the value "queue" for this parameter, the queue this message should be 
submitted to will be set to the value of $EXTENSION. By specifying 
"ticket", $EXTENSION will be interpreted as the id of the ticket this message
is related to.  "action" will allow the user to specify either "comment" or 
"correspond" in the address extension.


=head1 DESCRIPTION

The RT mail gateway is the primary mechanism for communicating with RT
via email. This program simply directs the email to the RT web server,
which handles filing correspondence and sending out any required mail.
It is designed to be run as part of the mail delivery process, either
called directly by the MTA or C<procmail>, or in a F<.forward> or
equivalent.

=head1 SETUP

Much of the set up of the mail gateway depends on your MTA and mail
routing configuration. However, you will need first of all to create an
RT user for the mail gateway and assign it a password; this helps to
ensure that mail coming into the web server did originate from the
gateway.

Next, you need to route mail to C<rt-mailgate> for the queues you're
monitoring. For instance, if you're using F</etc/aliases> and you have a
"bugs" queue, you will want something like this:

    bugs:         "|/opt/rt3/bin/rt-mailgate --queue bugs --action correspond
              --url http://rt.mycorp.com/"

    bugs-comment: "|/opt/rt3/bin/rt-mailgate --queue bugs --action comment
              --url http://rt.mycorp.com/"

Note that you don't have to run your RT server on your mail server, as
the mail gateway will happily relay to a different machine.

=head1 CUSTOMIZATION

By default, the mail gateway will accept mail from anyone. However,
there are situations in which you will want to authenticate users
before allowing them to communicate with the system. You can do this
via a plug-in mechanism in the RT configuration.

You can set the array C<@RT::MailPlugins> to be a list of plugins. The
default plugin, if this is not given, is C<Auth::MailFrom> - that is,
authentication of the person is done based on the C<From> header of the
email. If you have additional filters or authentication mechanisms, you
can list them here and they will be called in order:

    @RT::MailPlugins = (
        "Filter::SpamAssassin",
        "Auth::LDAP",
        # ...
    );

See the documentation for any additional plugins you have.

You may also put Perl subroutines into the C<@RT::MailPlugins> array, if
they behave as described below.

=head1 WRITING PLUGINS

What's actually going on in the above is that C<@RT::MailPlugins> is a
list of Perl modules; RT prepends C<RT::Interface::Email::> to the name,
to form a package name, and then C<use>'s this module. The module is
expected to provide a C<GetCurrentUser> subroutine, which takes a hash of
several parameters: 

=over 4

=item Message 

A C<MIME::Entity> object representing the email
=item CurrentUser 

An C<RT::CurrentUser> object 

=item AuthStat

The authentication level returned from the previous plugin.

=item Ticket [OPTIONAL]

The ticket under discussion 

=item Queue [OPTIONAL]

If we don't already have a ticket id, we need to know which queue we're talking about

=item Action

The action being performed. At the moment, it's one of "comment" or "correspond"

=back 4

It returns two values, the new C<RT::CurrentUser> object, and the new
authentication level. The authentication level can be zero, not allowed
to communicate with RT at all, (a "permission denied" error is mailed to
the correspondent) or one, which is the normal mode of operation.
Additionally, if C<-1> is returned, then the processing of the plug-ins
stops immediately and the message is ignored. 

=cut

