#!/usr/bin/perl
# BEGIN LICENSE BLOCK
# 
#  Copyright (c) 2002-2003 Jesse Vincent <jesse@bestpractical.com>
#  
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of version 2 of the GNU General Public License 
#  as published by the Free Software Foundation.
# 
#  A copy of that license should have arrived with this
#  software, but in any event can be snarfed from www.gnu.org.
# 
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
# 
# END LICENSE BLOCK

#$Header: /raid/cvsroot/fm/sbin/factory,v 1.1 2001/09/10 06:29:47 jesse Exp $
use DBI;

my $database = shift;
my $namespace = shift;

my $CollectionBaseclass = 'RT::FM::SearchBuilder';
my $RecordBaseclass = 'RT::FM::Record';

my $driver = 'mysql';
my $hostname = 'localhost';
my $user = 'root';
my $password = '';
my $dsn = "DBI:$driver:database=$database;host=$hostname";

my $dbh = DBI->connect($dsn, $user, $password);

 
#get all tables out of database
my @tables = $dbh->tables();

my %tablemap;

foreach my $table (@tables) {
	$tablemap{$table} = $table;
}
$tablemap{'CreatedBy'} = 'User';
$tablemap{'UpdatedBy'} = 'User';



foreach my $table (@tables) {

    my $tablesingle = $table;
    $tablesingle =~ s/s$//;

    my %requirements;

    my $CollectionClassName = $namespace."::".$tablesingle."Collection";
    my $RecordClassName = $namespace."::".$tablesingle;
    
    my $path = $namespace;
    $path =~ s/::/\//g;
    
    my $RecordClassPath = $path."/".$tablesingle.".pm";
    my $CollectionClassPath = $path."/".$tablesingle."Collection.pm";


    
    #create a collection class
    my $CreateInParams;
    my $CreateOutParams;
    my $ClassAccessible = "";
    my $FieldsPod = "";
    my $CreatePod = "";
    my $sth = $dbh->prepare("DESCRIBE $table");
    $sth->execute;
    while (my $row = $sth->fetchrow_hashref()) {
		my $field = $row->{'Field'};
		my $type = $row->{'Type'};
		my $default = $row->{'Default'};
		
		#generate the 'accessible' datastructure
		$ClassAccessible .= "        $field => {'read' => 1, 'write' => 1},\n";
		
		
		#generate pod for the accessible fields
		$FieldsPod .= "
=item $field

Returns the current value of $field. 
(In the database, $field is stored as $type.)


=item Set$field VALUE

Set $field to VALUE. 
Returns (1, 'Status message') on success and (0, 'Error Message') on failure.
(In the database, $field will be stored as a $type.)

=cut

";

if ($tablemap{$field}) { 
$FieldsPod .= "
=item ${field}Obj

Returns the $tablemap{$field} Object which has the id returned by $field


=cut

sub ${field}Obj {
	my \$self = shift;
	my \$$field = new ${namespace}::$tablemap{$field}(\$self->CurrentUser);
	\$$field->Load(\$self->$field());
	return(\$$field);
}
";
$requirements{$tablemap{$field}} = "use ${namespace}::$tablemap{$field};";

}
		#generate create statement
		$CreateInParams .= "                $field => undef,\n";
                $CreateOutParams .= "                         $field => \$args{'$field'},\n";


		#gerenate pod for the create statement	
		$CreatePod .= "  $type '$field'";
		$CreatePod .= " defaults to '$default'" if ($default);
		$CreatePod .= ".\n";

	}

        $Create = "
sub Create {
    my \$self = shift;
    my \%args = ( 
$CreateInParams,
		  \@_);
    \$self->SUPER::Create(
$CreateOutParams);

}
";
	$CreatePod .= "\n=cut\n\n";


my $CollectionClass = "

# \$Header\$
# Autogenerated by DBIx::SearchBuilder factory  (by <jesse\@fsck.com>)

=head1 NAME

  $CollectionClassName -- Class Description
 
=head1 SYNOPSIS

  use $CollectionClassName

=head1 DESCRIPTION


=head1 METHODS

=cut

package $CollectionClassName;

use $CollectionBaseclass;
use $RecordClassName;

\@ISA= qw($CollectionBaseclass);


sub _Init {
    my \$self = shift;
    \$self->{'table'} = '$table';
    \$self->{'primary_key'} = 'id';
    return ( \$self->SUPER::_Init(\@_) );
}


=item NewItem

Returns an empty new $RecordClassName item

=cut

sub NewItem {
    my \$self = shift;
    return(new $RecordClassName(\@_));
}

1;
";

my $RecordClassHeader = "
# \$Header\$
# Autogenerated by DBIx::SearchBuilder factory  (by <jesse\@fsck.com>)

=head1 NAME

$RecordClassName


=head1 SYNOPSIS

=head1 DESCRIPTION

=head1 METHODS

=cut

package $RecordClassName;
use $RecordBaseclass; 
";

foreach my $key (keys %requirements) {
	$RecordClassHeader .= $requirements{$key} . "\n";
}
$RecordClassHeader .="

use vars qw( \@ISA );
\@ISA= qw( $RecordBaseclass );

sub _Init {
  my \$self = shift; 

  \$self->Table('$table');
  \$self->SUPER::_Init(\@_);
}

";








my $RecordClass = "

$RecordClassHeader

$RecordInit

=item Create PARAMHASH

Create takes a hash of values and creates a row in the database:

$CreatePod

$Create

$FieldsPod

sub _ClassAccessible {
    {
     
$ClassAccessible
 }
};
1;
";


`mkdir -p $path`;

open (RECORD, ">$RecordClassPath");
print RECORD $RecordClass;
close (RECORD);

open (COL, ">$CollectionClassPath");
print COL $CollectionClass;
close($COL);

}



	
