
use strict;
use File::Find;
use File::Copy;
use Regexp::Common;
use Carp;

use vars qw ($DEBUG);

$DEBUG = 1;

@ARGV = <lib/RT/I18N/*.po> unless @ARGV;

foreach my $lang (@ARGV) {
    $lang =~ s|.*/||; $lang =~ s|\.po$||;
    # eval { update($lang) } or warn $@;
    update($lang);
}

sub update {
    my $lang = shift;

    print "Updating $lang...\n";
    
    my (%Lexicon, %file);
    my $out = '';

    
    open LEXICON, "lib/RT/I18N/$lang.po" or warn $@;
    while (<LEXICON>) {
	if (1 .. /^$/) { $out .= $_; next }

	my $msgid = <LEXICON>;
	$msgid = <LEXICON> until $msgid =~ /^msgid/;

	my $msgstr = <LEXICON>;
	<LEXICON>;
	chomp $msgid;
	chomp $msgstr;
	$msgid =~ s/^msgid "(.*)"$/$1/ or die $msgid;
	$msgstr =~ s/^msgstr "(.*)"$/$1/ or die $msgstr;
	$Lexicon{$msgid}=$msgstr;
    }

    local $/;
    print "Done reading lexicon \n";

    File::Find::find({wanted => \&extract_strings_from_code, follow => 1}, '.');

    sub extract_strings_from_code {
	my $file = $_;
	return if ($File::Find::dir =~ 'lib/blib|lib/t/autogen');
	return if ($_ =~ /.bak$|~|,D|,B$/);
	return if ($_ =~ /^#/);
	print "Looking at $File::Find::name\n";
	my $filename = $File::Find::name; 
	open _, $file or die $!; $_ = <_>; $filename =~ s'^./'';

	my $line = 1;
	while (m!\G.*?<&\|/l(.*?)&>(.*?)</&>!sg) {
	    my ($vars, $str) = ($1, $2);
	    $line += ( () = ($& =~ /\n/g) ); # cryptocontext!
            $str =~ s/\\'/\'/g; 
            push @{$file{$str}}, [ $filename, $line, $vars ];
	}

	$line = 1;
	pos($_) = 0;

	while (m/\G.*?\bloc$RE{balanced}{-parens=>'()'}{-keep}/sg) {
	    my $match = $1;
	    $line += ( () = ($& =~ /\n/g) ); # cryptocontext!
	    my ($vars, $str);
	    if ($match =~ /\(($RE{delimited}{-delim=>'"'}{-esc}{-keep})(.*?)\)$/) {
		($vars, $str) = ($9, substr($1, 1, -1)); # reversed
	    }
	    elsif ($match =~ /\(($RE{delimited}{-delim=>"'"}{-esc}{-keep})(.*?)\)$/) {
		($vars, $str) = ($9, substr($1, 1, -1)); # reversed
	    }
	    else {
		next;
	    }
	    $vars =~ s/[\n\r]//g;
	    $str =~ s/\\'/\'/g; 
	    push @{$file{$str}}, [ $filename, $line, $vars ];
	}
    }

    foreach my $str (sort keys %file) {
	my $entry = $file{$str};

	$str =~ s/\\/\\\\/g;
	$str =~ s/\"/\\"/g;
	$str =~ s/\[_(\d+)\]/%$1/g;
	$str =~ s/~([\[\]])/$1/g;

	$file{$str} = $entry;
	$Lexicon{$str} ||= '';
    }

    my $is_english = ($lang =~/^en(?:[^A-Za-z]|$)/);

    delete $file{''};
    foreach (sort keys %Lexicon) {
	my $f = join(' ', sort map "$_->[0]:$_->[1]", @{$file{$_}});
	$f = " $f" if length $f;
	my $nospace = $_;
	$nospace =~ s/ +$//;

	if (!$Lexicon{$_} and $Lexicon{$nospace}) {
	    $Lexicon{$_} = $Lexicon{$nospace} . (' ' x (length($_) - length($nospace)));
	}

	next if !length($Lexicon{$_}) and $is_english;

	my %seen;
	$out .= "#:$f\n";
	foreach my $entry ( grep { $_->[2] } @{$file{$_}} ) {
	    my ($file, $line, $var) = @{$entry};
	    $var =~ s/^\s*,\s*//; $var =~ s/\s*$//;
	    $out .= "#. ($var)\n" unless $seen{$var}++;
	}
	$out .= "msgid \"$_\"\nmsgstr \"$Lexicon{$_}\"\n\n";
    }

    open _, ">lib/RT/I18N/$lang.po" or die $!;
    print _ $out;
    close _;

    return 1;
}

# pull strings out of the code.

