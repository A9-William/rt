#!/usr/bin/perl -w
# BEGIN LICENSE BLOCK
# 
# Copyright (c) 1996-2002 Jesse Vincent <jesse@bestpractical.com>
# 
# (Except where explictly superceded by other copyright notices)
# 
# This work is made available to you under the terms of Version 2 of
# the GNU General Public License. A copy of that license should have
# been provided with this software, but in any event can be snarfed
# from www.gnu.org
# 
# This work is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# 
# Unless otherwise specified, all modifications, corrections or
# extensions to this work which alter its source code become the
# property of Best Practical Solutions, LLC when submitted for
# inclusion in the work.
# 
# 
# END LICENSE BLOCK

#



use strict;
use vars qw($VERSION $Handle $Nobody $SystemUser $item);

use lib "!!RT_LIB_PATH!!";

#This drags in  RT's config.pm
# We do it in a begin block because RT::Handle needs to know the type to do its
# inheritance
BEGIN {
        use RT;
        RT::LoadConfig();
	RT::InitLogging();
}
use Carp;

use RT::User;
use RT::CurrentUser;

# 
my $LastVersion = shift || undef;
my $LastMinorVersion = undef;

#connect to the db
require RT::Handle;
$RT::Handle = RT::Handle->new();
$RT::Handle->Connect();

#Put together a current user object so we can create a User object
my $CurrentUser = new RT::CurrentUser();

if ($LastVersion) {
    if ( $LastVersion =~ /^2.1.(\d+)$/ ) {
        $LastMinorVersion = $1;
        print "Looking for new objects to add to the database"
          . " since $LastVersion\n\n";
    }
    else {
        print "This tool does not support upgrades from non 2.1.x versions";
    }
}
else {    # this is a virgin install
    print "Checking for existing system user...";
    my $test_user = RT::User->new($CurrentUser);
    $test_user->Load('RT_System');
    if ( $test_user->id ) {
        print "Found!\n\nYou appear to have already run insertdata.\n"
          . "Exiting, so as not to clobber your existing data. To ERASE your\n"
          . "RT database and start over, type 'make dropdb; make install' in\n"
          . "the RT installation directory. If you just meant to upgrade the\n"
          . "content of your database, rerun this program as: \n",
          "       $0 <version>\n"
          . "where <version> is the last RELEASED version of RT you installed\n"
          . "for example, if you're upgrading from 2.0.4, you'd type:\n"
          . "       $0 2.0.4\n";
        exit(-1);

    }
    else {
        print "not found.  This appears to be a new installation.\n";
    }

    print "Creating system user...";
    my $RT_System = new RT::User($CurrentUser);

    my ( $val, $msg ) = $RT_System->_BootstrapCreate(
        Name     => 'RT_System',
        RealName => 'The RT System itself',
        Comments =>
'Do not delete or modify this user. It is integral to RT\'s internal database structures',
        Creator    => '1'
    );

    unless ($val) {
        print "$msg\n";
        exit(1);
    }
    print "done.\n";
    $RT::Handle->dbh->disconnect();
}

#now that we bootstrapped that little bit, we can use the standard RT cli
# helpers  to do what we need

use RT::Interface::CLI qw(CleanEnv GetCurrentUser GetMessageContent);

#Clean out all the nasties from the environment
CleanEnv();

#Load etc/config.pm and drop privs
RT::LoadConfig();

#Connect to the database and get RT::SystemUser and RT::Nobody loaded
RT::Init;

$CurrentUser->LoadByName('RT_System');


print "Creating Superuser  ACL...";
use RT::ACE;
use RT::Group;

        my $superuser_ace = RT::ACE->new($CurrentUser);
        $superuser_ace->_BootstrapCreate(
            PrincipalId        => ACLEquivGroupId($CurrentUser->Id),
            PrincipalType  => 'Group',
            RightName      => 'SuperUser',
            ObjectType     => 'RT::System',
            ObjectId => '1');

# {{{ Groups 

my @groups;
unless ($LastVersion) {
    @groups = (
        {
            Name        => '',
            Type        => 'Everyone',				# loc
            Domain      => 'SystemInternal',
            Instance    => '',
            Description => 'Pseudogroup for internal use',	# loc
        },
        {
            Type        => 'Privileged',			# loc
            Domain      => 'SystemInternal',
            Instance    => '',
            Name        => '',
            Description => 'Pseudogroup for internal use',	# loc
        },
        {
            Name        => '',
            Type        => 'Unprivileged',			# loc
            Domain      => 'SystemInternal',
            Instance    => '',
            Description => 'Pseudogroup for internal use',	# loc
        },
        {
            Name        => '',
            Type        => 'Owner',				# loc
            Domain      => 'RT::System-Role',
            Instance    => '',
            Description => 'SystemRolegroup for internal use',	# loc
        },
        {
            Name        => '',
            Type        => 'Requestor',				# loc
            Domain      => 'RT::System-Role',
            Instance    => '',
            Description => 'SystemRolegroup for internal use',	# loc
        },
        {
            Name        => '',
            Type        => 'Cc',				# loc
            Domain      => 'RT::System-Role',
            Instance    => '',
            Description => 'SystemRolegroup for internal use',	# loc
        },
        {
            Name        => '',
            Type        => 'AdminCc',				# loc
            Domain      => 'RT::System-Role',
            Instance    => '',
            Description => 'Pseudogroup for internal use',	# loc
        },
    );
}

# }}}

print "Creating groups...";
foreach $item (@groups) {
    my $new_entry = RT::Group->new($CurrentUser);
    my ($return, $msg)   = $new_entry->_Create(%$item);
    print "(Error: $msg)" unless ($return);
    print $return. ".";
}
print "done.\n";

# {{{ Users

my @users;

unless ($LastVersion) {
    @users = (
        {
            Name     => 'Nobody',
            RealName => 'Nobody in particular',
            Comments => 'Do not delete or modify this user. It is integral '
              . 'to RT\'s internal data structures',
            Privileged => '0',
        },

        {
            Name         => 'root',
            Gecos        => 'root',
            RealName     => 'Enoch Root',
            Password     => 'password',
            EmailAddress => "root\@localhost",
            Comments     => 'SuperUser',
            Privileged   => '1',
        }
    );
}

# }}}
print "Creating users...";
use RT::User;
foreach $item (@users) {
    my $new_entry = new RT::User($CurrentUser);
    my ( $return, $msg ) = $new_entry->Create(%$item);
    print "(Error: $msg)" unless ($return);
    print $return. ".";
}
print "done.\n";


# {{{ ACL
my @acl;
unless ($LastVersion) {
    @acl = (    
        { 
            UserId    => 'Nobody', # - principalId
            Right      => 'OwnTicket',
        },

        {
            UserId    => 'root', # - principalid
            Right      => 'SuperUser',
        },

    );
}

# }}}
print "Creating ACL...";
for $item (@acl) {

    my $princ = RT::User->new($CurrentUser);
    $princ->Load($item->{'UserId'});
    my ($return, $msg) = $princ->PrincipalObj->GrantRight(Right => $item->{'Right'}, Object=> $RT::System);
    if ($return) {
	    print $return. "."; 
    } else {	
	    print $msg . ".";

    }
 
}
print "done.\n";


# {{{ Queues

my @queues;
unless ($LastVersion) {
    @queues = (
        {
            Name              => 'General',
            Description       => 'The default queue',
            CorrespondAddress => "rt\@localhost",
            CommentAddress    => "rt-comment\@localhost"
        },
    );
}

# }}}

# {{{ ScripActions

my @ScripActions;

unless ($LastVersion) {
    @ScripActions = (

        {
            Name        => 'AutoreplyToRequestors',			# loc
            Description => 'Always sends a message to the requestors independent of message sender', # loc
            ExecModule => 'Autoreply',
            Argument   => 'Requestor'
        },
        {
            Name        => 'Notify Requestors',				# loc
            Description => 'Sends a message to the requestors',		# loc
            ExecModule  => 'Notify',
            Argument    => 'Requestor'
        },
        {
            Name        => 'Notify Owner as Comment',			# loc
            Description => 'Sends mail to the owner',			# loc
            ExecModule  => 'NotifyAsComment',
            Argument    => 'Owner'
        },
        {
            Name        => 'Notify Owner',				# loc
            Description => 'Sends mail to the owner',			# loc
            ExecModule  => 'Notify',
            Argument    => 'Owner'
        },
        {
            Name        => 'Notify AdminCcs as Comment',		# loc
            Description => 'Sends mail to the administrative Ccs as a comment', # loc
            ExecModule  => 'NotifyAsComment',
            Argument    => 'AdminCc'
        },
        {
            Name        => 'Notify AdminCcs',				# loc
            Description => 'Sends mail to the administrative Ccs',	# loc
            ExecModule  => 'Notify',
            Argument    => 'AdminCc'
        },

        {
            Name        => 'Notify Requestors and Ccs as Comment',	# loc
            Description => 'Send mail to requestors and Ccs as a comment', # loc
            ExecModule  => 'NotifyAsComment',
            Argument    => 'Requestor,Cc'
        },

        {
            Name        => 'Notify Requestors and Ccs',			# loc
            Description => 'Send mail to requestors and Ccs',		# loc
            ExecModule  => 'Notify',
            Argument    => 'Requestor,Cc'
        },

        {
            Name        => 'Notify Requestors, Ccs and AdminCcs as Comment', # loc
            Description => 'Send mail to all watchers as a "comment"',	# loc
            ExecModule  => 'NotifyAsComment'	,
            Argument    => 'All'
        },
        {
            Name        => 'Notify Requestors, Ccs and AdminCcs',	# loc
            Description => 'Send mail to all watchers',			# loc
            ExecModule  => 'Notify',
            Argument    => 'All'
        },
        {
            Name        => 'Notify Other Recipients as Comment',	# loc
            Description => 'Sends mail to explicitly listed Ccs and Bccs', # loc
            ExecModule  => 'NotifyAsComment',
            Argument    => 'OtherRecipients'
        },
        {
            Name        => 'Notify Other Recipients',			# loc
            Description => 'Sends mail to explicitly listed Ccs and Bccs', # loc
            ExecModule  => 'Notify',
            Argument    => 'OtherRecipients'
        },
        {
            Name        => 'User Defined',				# loc
            Description => 'Perform a user-defined action',		# loc
            ExecModule  => 'UserDefined',
        },
        {
            Name        => 'Create Tickets',				# loc
            Description => 'Create new tickets based on this scrip\'s template', # loc
            ExecModule  => 'CreateTickets',
        },
    );
}

# }}}

# {{{ ScripConditions

my @ScripConditions;
unless ($LastVersion) {
    @ScripConditions = (
        {
            Name                 => 'On Create',				# loc
            Description          => 'When a ticket is created',			# loc
            ApplicableTransTypes => 'Create',
            ExecModule           => 'AnyTransaction',
        },

        {
            Name                 => 'On Transaction',				# loc
            Description          => 'When anything happens',			# loc
            ApplicableTransTypes => 'Any',
            ExecModule           => 'AnyTransaction',
        },
        {

            Name                 => 'On Correspond',				# loc
            Description          => 'Whenever correspondence comes in',		# loc
            ApplicableTransTypes => 'Correspond',
            ExecModule           => 'AnyTransaction',
        },

        {

            Name                 => 'On Comment',				# loc
            Description          => 'Whenever comments come in',		# loc
            ApplicableTransTypes => 'Comment',
            ExecModule           => 'AnyTransaction'
        },
        {

            Name                 => 'On Status Change',				# loc
            Description          => 'Whenever a ticket\'s status changes',	# loc
            ApplicableTransTypes => 'Status',
            ExecModule           => 'AnyTransaction',

        },
        {

            Name                 => 'On Owner Change',				# loc
            Description          => 'Whenever a ticket\'s owner changes',	# loc
            ApplicableTransTypes => 'Set',
            ExecModule           => 'OwnerChange',

        },
        {

            Name                 => 'On Queue Change',				# loc
            Description          => 'Whenever a ticket\'s queue changes',	# loc
            ApplicableTransTypes => 'Set',
            ExecModule           => 'QueueChange',

        },
        {
            Name                 => 'On Resolve',				# loc
            Description          => 'Whenever a ticket is resolved',		# loc
            ApplicableTransTypes => 'Status',
            ExecModule           => 'StatusChange',
            Argument             => 'resolved'

        },

        {
            Name                 => 'User Defined',				# loc
            Description          => 'Whenever a user-defined condition occurs',	# loc
            ApplicableTransTypes => 'Any',
            ExecModule           => 'UserDefined'

        },
    );
}

# }}}

# {{{ Templates
my @templates;

unless ($LastVersion) {
    @templates = (
        {
            Queue       => '0',
            Name        => 'Blank',					# loc
            Description => 'A blank template',				# loc
            Content     => '',
            },
        {    
            Queue       => '0',
            Name        => 'Autoreply',					# loc
            Description => 'Default Autoresponse Template',		# loc
            Content     => 'Subject: AutoReply: {$Ticket->Subject}


Greetings,

This message has been automatically generated in response to the
creation of a trouble ticket regarding:
	"{$Ticket->Subject()}", 
a summary of which appears below.

There is no need to reply to this message right now.  Your ticket has been
assigned an ID of [{$rtname} #{$Ticket->id()}].

Please include the string:

         [{$rtname} #{$Ticket->id}]

in the subject line of all future correspondence about this issue. To do so, 
you may reply to this message.

                        Thank you,
                        {$Ticket->QueueObj->CorrespondAddress()}

-------------------------------------------------------------------------
{$Transaction->Content()}
'
        },

        {
            Queue       => '0',
            Name        => 'Transaction',				# loc
            Description => 'Default transaction template',		# loc
            Content     => '


{$Transaction->CreatedAsString}: Request {$Ticket->id} was acted upon.
Transaction: {$Transaction->Description}
       Queue: {$Ticket->QueueObj->Name}
     Subject: {$Transaction->Subject || $Ticket->Subject || "(No subject given)"}
       Owner: {$Ticket->OwnerObj->Name}
  Requestors: {$Ticket->RequestorAddresses}
      Status: {$Ticket->Status}
 Ticket <URL: {$RT::WebURL}Ticket/Display.html?id={$Ticket->id} >
-------------------------------------------------------------------------
{$Transaction->Content()}'
        },

        {

            Queue       => '0',
            Name        => 'AdminCorrespondence',			# loc
            Description => 'Default admin correspondence template',	# loc
            Content     => '


<URL: {$RT::WebURL}Ticket/Display.html?id={$Ticket->id} >

{$Transaction->Content()}'
        },

        {
            Queue       => '0',
            Name        => 'Correspondence',				# loc
            Description => 'Default correspondence template',		# loc
            Content     => '

{$Transaction->Content()}'
        },

        {
            Queue       => '0',
            Name        => 'AdminComment',				# loc
            Description => 'Default admin comment template',		# loc
            Content     =>
'Subject: [Comment] {my $s=($Transaction->Subject||$Ticket->Subject); $s =~ s/\\[Comment\\]//g; $comment =~ s/^Re//i; $s;}


{$RT::WebURL}Ticket/Display.html?id={$Ticket->id}
This is a comment.  It is not sent to the Requestor(s):

{$Transaction->Content()}
'
        },

        {
            Queue       => '0',
            Name        => 'StatusChange',				# loc
            Description => 'Ticket status changed',			# loc
            Content     => 'Subject: Status Changed to: {$Transaction->NewValue}


{$RT::WebURL}Ticket/Display.html?id={$Ticket->id}

{$Transaction->Content()}
'
        },

        {

            Queue       => '0',
            Name        => 'Resolved',					# loc
            Description => 'Ticket Resolved',				# loc
            Content     => 'Subject: Ticket Resolved

According to our records, your request has been resolved. If you have any
further questions or concerns, please respond to this message.
'
        }
    );
}

# }}}

print "Creating queues...";
use RT::Queue;
for $item (@queues) {
    my $new_entry = new RT::Queue($CurrentUser);
    my ( $return, $msg ) = $new_entry->Create(%$item);
    print "(Error: $msg)" unless ($return);
    print $return. ".";
}

print "done.\n";
print "Creating ScripActions...";

use RT::ScripAction;
for $item (@ScripActions) {
    my $new_entry = RT::ScripAction->new($CurrentUser);
    my $return    = $new_entry->Create(%$item);
    print $return. ".";
}

print "done.\n";
print "Creating ScripConditions...";

use RT::ScripCondition;
for $item (@ScripConditions) {
    my $new_entry =  RT::ScripCondition->new($CurrentUser);
    my $return    = $new_entry->Create(%$item);
    print $return. ".";
}

print "done.\n";

print "Creating templates...";

use RT::Template;
for $item (@templates) {
    my $new_entry = new RT::Template($CurrentUser);
    my $return    = $new_entry->Create(%$item);
    print $return. ".";
}
print "done.\n";

$RT::Handle->Disconnect();


sub ACLEquivGroupId {
        my $username = shift;
        my $user = RT::User->new($CurrentUser);
        $user->Load($username);
        my $equiv_group = RT::Group->new($CurrentUser);
        $equiv_group->LoadACLEquivalenceGroup($user);
        return ($equiv_group->Id)
}
1;
