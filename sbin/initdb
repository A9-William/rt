#!/usr/bin/perl -w
# BEGIN LICENSE BLOCK
# 
# Copyright (c) 1996-2002 Jesse Vincent <jesse@bestpractical.com>
# 
# (Except where explictly superceded by other copyright notices)
# 
# This work is made available to you under the terms of Version 2 of
# the GNU General Public License. A copy of that license should have
# been provided with this software, but in any event can be snarfed
# from www.gnu.org
# 
# This work is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# 
# Unless otherwise specified, all modifications, corrections or
# extensions to this work which alter its source code become the
# property of Best Practical Solutions, LLC when submitted for
# inclusion in the work.
# 
# 
# END LICENSE BLOCK

use strict;
use vars qw($PROMPT $ACTION $DEBUG);

use lib "!!RT_LIB_PATH!!";

BEGIN {
        use RT;
        RT::LoadConfig();
}

$| = 1;    #unbuffer that output.

$DEBUG = 0;

$ACTION = shift @ARGV;

require RT::Handle;
my $Handle = RT::Handle->new($RT::DatabaseType);
$Handle->BuildDSN;
my $dbh ;
if ( $ACTION eq 'create' ) {
        my $dsn = $Handle->DSN;
        $dsn =~ s/dbname=$RT::DatabaseName//;
     $dbh = DBI->connect( $dsn, $RT::DatabaseDBA, $RT::DatabaseDBAPassword ) || die $DBI::errstr;
    print "Now creating a database for RT.\n";
    create_db();
}
elsif ( $ACTION eq 'drop' ) {
     unless (  $dbh = DBI->connect( $Handle->DSN, $RT::DatabaseDBA, $RT::DatabaseDBAPassword ) )
     
        {  warn $DBI::errstr;
           warn "Database doesn't appear to exist. Aborting database drop.";
           exit(0);
        }
    print "Now dropping the RT2 database.\n";
    drop_db();
}
elsif ( $ACTION eq 'insert' ) {
     $dbh = DBI->connect( $Handle->DSN, $RT::DatabaseDBA, $RT::DatabaseDBAPassword ) || die $DBI::errstr;
    print "Now populating database schema.\n";
    insert_schema();
}
elsif ( $ACTION eq 'acl' ) {
     $dbh = DBI->connect( $Handle->DSN, $RT::DatabaseDBA, $RT::DatabaseDBAPassword ) || die $DBI::errstr;
    insert_acl();
}

else {
    print STDERR '$ACTION unspecified. Makefile error. It was ' . $ACTION;
    exit(-1);
}

# {{{ sub insert_schema
sub insert_schema {
    my (@schema);
    print "Creating database schema.\n";


    if ( -f $RT::EtcPath . "/schema." . $RT::DatabaseType ) {
        open( SCHEMA, "<" . $RT::EtcPath . "/schema." . $RT::DatabaseType );
        my $statement = "";
        foreach my $line (<SCHEMA>) {
            $statement .= $line;
            if ( $line =~ /;$/ ) {
                $statement =~ s/;$//g;
                push @schema, $statement;
                $statement = "";
            }
        }

        foreach my $statement (@schema) {
            print STDERR $statement if $DEBUG;
            my $sth = $dbh->prepare($statement) or die $dbh->errstr;
            unless ( $sth->execute ) {
                die "Problem with statement:\n $statement\n" . $sth->errstr;
            }
        }

    }
    else {
        die "Couldn't find schema file for " . $RT::DatabaseType . "\n";
    }
    $dbh->disconnect;
    print "schema sucessfully inserted\n";

}

# }}}

# {{{ sub drop_db
sub drop_db {
    if ($PROMPT) {
        print <<END;

About to drop $RT::DatabaseType database $RT::DatabaseName.
WARNING: This will erase all data in $RT::DatabaseName.

END
        exit unless _yesno();

    }

    print "Dropping $RT::DatabaseType database $RT::DatabaseName.\n";


    $dbh->do("Drop DATABASE $RT::DatabaseName") or warn $DBI::errstr;
}

# }}}
# {{{ sub create_db
sub create_db {
    print "Creating $RT::DatabaseType database $RT::DatabaseName.\n";


    $dbh->do("CREATE DATABASE $RT::DatabaseName") or die $DBI::errstr;
}

# }}}

# {{{ sub _yesno
sub _yesno {
    print "Proceed [y/N]:";
    my $x = scalar(<STDIN>);
    $x =~ /^y/i;
}

# }}}

# {{{ insert_acls
sub insert_acl {
        
    if ( $RT::DatabaseType =~ /^oracle$/i ) {
        do $RT::EtcPath . "acl.Oracle"
          || die "Couldn't find ACLS for Oracle\n" . $@;
        ;
    }
    elsif ( $RT::DatabaseType =~ /^pg$/i ) {
        do $RT::EtcPath . "acl.Pg" || die "Couldn't find ACLS for Pg\n" . $@;
    }
    elsif ( $RT::DatabaseType =~ /^mysql$/i ) {
        do $RT::EtcPath . "acl.mysql"
          || die "Couldn't find ACLS for mysql\n" . $@;
    }
    else {
        die "Unknown RT database type";
    }

    my @acl = acl($dbh);
    foreach my $statement ( @acl ) {
        print STDERR $statement if $DEBUG;
        my $sth = $dbh->prepare($statement) or die $dbh->errstr;
        unless ( $sth->execute ) {
            die "Problem with statement:\n $statement\n" . $sth->errstr;
        }
    }
        $dbh->disconnect();
}

# }}}

