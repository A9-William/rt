#!@PERL@ -w
# BEGIN LICENSE BLOCK
# 
# Copyright (c) 1996-2002 Jesse Vincent <jesse@bestpractical.com>
# 
# (Except where explictly superceded by other copyright notices)
# 
# This work is made available to you under the terms of Version 2 of
# the GNU General Public License. A copy of that license should have
# been provided with this software, but in any event can be snarfed
# from www.gnu.org
# 
# This work is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# 
# Unless otherwise specified, all modifications, corrections or
# extensions to this work which alter its source code become the
# property of Best Practical Solutions, LLC when submitted for
# inclusion in the work.
# 
# 
# END LICENSE BLOCK

use strict;
use vars qw($PROMPT $DEBUG $VERSION $Handle $Nobody $SystemUser $item);

use lib "@RT_LIB_PATH@";

#This drags in  RT's config.pm
# We do it in a begin block because RT::Handle needs to know the type to do its
# inheritance
use RT;
use Carp;
use RT::User;
use RT::CurrentUser;
use RT::Template;
use RT::ScripAction;
use RT::ACE;
use RT::Group;
use RT::User;
use RT::Queue;
use RT::ScripCondition;


    RT::LoadConfig();

use Getopt::Long;

my %args;

GetOptions (\%args, 'action=s', 'dba=s', 'dba-password=s');

$| = 1;    #unbuffer that output.

$DEBUG = 0;


require RT::Handle;
my $Handle = RT::Handle->new($RT::DatabaseType);
$Handle->BuildDSN;
my $dbh;
if ($args{'action'} eq 'init') {
    $dbh = DBI->connect( get_system_dsn(), $args{'dba'}, $args{'dba-password'} )
      || die "Failed to connect to " . get_system_dsn() . " as $args{'dba'}: $DBI::errstr";
    print "Now creating a database for RT.\n";
    create_db();


    $dbh = DBI->connect( $Handle->DSN, $args{'dba'}, $args{'dba-password'} )
      || die $DBI::errstr;


    print "Now populating database schema.\n";
    insert_schema();
    print "Now inserting database ACLs\n";
    insert_acl();
    print "Now inserting RT data\n";
    insert_data();

}
elsif ( $args{'action'} eq 'drop' ) {
    unless ( $dbh = DBI->connect( get_system_dsn(), $args{'dba'}, $args{'dba-password'} ) ) {
        warn $DBI::errstr;
        warn "Database doesn't appear to exist. Aborting database drop.";
        exit(0);
    }
    print "Now dropping the RT2 database.\n";
    drop_db();
}
else {
    print STDERR 'Action unspecified. Makefile error. It was ' . $args{'action'};
    exit(-1);
}

# {{{ sub insert_schema
sub insert_schema {
    my (@schema);
    print "Creating database schema.\n";

    if ( -f $RT::EtcPath . "/schema." . $RT::DatabaseType ) {
        open( SCHEMA, "<" . $RT::EtcPath . "/schema." . $RT::DatabaseType );
        my $statement = "";
        foreach my $line (<SCHEMA>) {
            $statement .= $line;
            if ( $line =~ /;$/ ) {
                $statement =~ s/;$//g;
                push @schema, $statement;
                $statement = "";
            }
        }

        foreach my $statement (@schema) {
            print STDERR $statement if $DEBUG;
            my $sth = $dbh->prepare($statement) or die $dbh->errstr;
            unless ( $sth->execute ) {
                die "Problem with statement:\n $statement\n" . $sth->errstr;
            }
        }

    }
    else {
        die "Couldn't find schema file for " . $RT::DatabaseType . "\n";
    }
    $dbh->disconnect;
    print "schema sucessfully inserted\n";

}

# }}}

# {{{ sub drop_db
sub drop_db {
    return if ( $RT::DatabaseType eq 'SQLite' );
    if ($PROMPT) {
        print <<END;

About to drop $RT::DatabaseType database $RT::DatabaseName.
WARNING: This will erase all data in $RT::DatabaseName.

END
        exit unless _yesno();

    }

    print "Dropping $RT::DatabaseType database $RT::DatabaseName.\n";

    $dbh->do("Drop DATABASE $RT::DatabaseName") or warn $DBI::errstr;
}

# }}}

# {{{ sub create_db
sub create_db {
    return if ( $RT::DatabaseType eq 'SQLite' );
    print "Creating $RT::DatabaseType database $RT::DatabaseName.\n";

    $dbh->do("CREATE DATABASE $RT::DatabaseName") or die $DBI::errstr;
}

# }}}

# {{{ sub _yesno
sub _yesno {
    print "Proceed [y/N]:";
    my $x = scalar(<STDIN>);
    $x =~ /^y/i;
}

# }}}

# {{{ insert_acls
sub insert_acl {

    if ( $RT::DatabaseType =~ /^oracle$/i ) {
        do $RT::EtcPath . "/acl.Oracle"
          || die "Couldn't find ACLS for Oracle\n" . $@;
    }
    elsif ( $RT::DatabaseType =~ /^pg$/i ) {
        do $RT::EtcPath . "/acl.Pg" || die "Couldn't find ACLS for Pg\n" . $@;
    }
    elsif ( $RT::DatabaseType =~ /^mysql$/i ) {
        do $RT::EtcPath . "/acl.mysql"
          || die "Couldn't find ACLS for mysql in " . $RT::EtcPath . "\n" . $@;
    }
    elsif ( $RT::DatabaseType =~ /^SQLite$/i ) {
        return;
    }
    else {
        die "Unknown RT database type";
    }

    my @acl = acl($dbh);
    foreach my $statement (@acl) {
        print STDERR $statement if $DEBUG;
        my $sth = $dbh->prepare($statement) or die $dbh->errstr;
        unless ( $sth->execute ) {
            die "Problem with statement:\n $statement\n" . $sth->errstr;
        }
    }
    $dbh->disconnect();
}

# }}}

=head2 get_system_dsn

Returns a dsn suitable for database creates and drops
and user creates and drops

=cut

sub get_system_dsn {

    my $dsn = $Handle->DSN;

    #with mysql, you want to connect sans database to funge things
    if ( $RT::DatabaseType eq 'mysql' ) {
        $dsn =~ s/dbname=$RT::DatabaseName//;

        # with postgres, you want to connect to database1
    }
    elsif ( $RT::DatabaseType eq 'Pg' ) {
        $dsn =~ s/dbname=$RT::DatabaseName/dbname=template1/;
    }
    return $dsn;
}



sub insert_data {

RT::InitLogging();

#connect to the db, for actual RT work
require RT::Handle;
$RT::Handle = RT::Handle->new();
$RT::Handle->Connect();

#Put together a current user object so we can create a User object
my $CurrentUser = new RT::CurrentUser();

print "Checking for existing system user...";
my $test_user = RT::User->new($CurrentUser);
$test_user->Load('RT_System');
if ( $test_user->id ) {
    print "found!\n\nYou appear to have a functional RT database.\n"
      . "Exiting, so as not to clobber your existing data.\n";
    exit(-1);

}
else {
    print "not found.  This appears to be a new installation.\n";
}

print "Creating system user...";
my $RT_System = new RT::User($CurrentUser);

my ( $val, $msg ) = $RT_System->_BootstrapCreate(
    Name     => 'RT_System',
    RealName => 'The RT System itself',
    Comments =>
'Do not delete or modify this user. It is integral to RT\'s internal database structures',
    Creator => '1' );

unless ($val) {
    print "$msg\n";
    exit(1);
}
print "done.\n";
$RT::Handle->dbh->disconnect();

#now that we bootstrapped that little bit, we can use the standard RT cli
# helpers  to do what we need

use RT::Interface::CLI qw(CleanEnv GetCurrentUser GetMessageContent);

#Clean out all the nasties from the environment
CleanEnv();

#Connect to the database and get RT::SystemUser and RT::Nobody loaded
RT::Init;

$CurrentUser->LoadByName('RT_System');

print "Creating Superuser  ACL...";

my $superuser_ace = RT::ACE->new($CurrentUser);
$superuser_ace->_BootstrapCreate(
                             PrincipalId => ACLEquivGroupId( $CurrentUser->Id ),
                             PrincipalType => 'Group',
                             RightName     => 'SuperUser',
                             ObjectType    => 'RT::System',
                             ObjectId      => '1' );

my @users = (
    {  Name     => 'Nobody',
       RealName => 'Nobody in particular',
       Comments => 'Do not delete or modify this user. It is integral '
         . 'to RT\'s internal data structures',
       Privileged => '0', },

    {  Name         => 'root',
       Gecos        => 'root',
       RealName     => 'Enoch Root',
       Password     => 'password',
       EmailAddress => "root\@localhost",
       Comments     => 'SuperUser',
       Privileged   => '1', } );

my @groups = (
    { Name        => '',
      Type        => 'Everyone',                        # loc
      Domain      => 'SystemInternal',
      Instance    => '',
      Description => 'Pseudogroup for internal use',    # loc
    },
    { Type        => 'Privileged',                      # loc
      Domain      => 'SystemInternal',
      Instance    => '',
      Name        => '',
      Description => 'Pseudogroup for internal use',    # loc
    },
    { Name        => '',
      Type        => 'Unprivileged',                    # loc
      Domain      => 'SystemInternal',
      Instance    => '',
      Description => 'Pseudogroup for internal use',    # loc
    },
    { Name        => '',
      Type        => 'Owner',                               # loc
      Domain      => 'RT::System-Role',
      Instance    => '',
      Description => 'SystemRolegroup for internal use',    # loc
    },
    { Name        => '',
      Type        => 'Requestor',                           # loc
      Domain      => 'RT::System-Role',
      Instance    => '',
      Description => 'SystemRolegroup for internal use',    # loc
    },
    { Name        => '',
      Type        => 'Cc',                                  # loc
      Domain      => 'RT::System-Role',
      Instance    => '',
      Description => 'SystemRolegroup for internal use',    # loc
    },
    { Name        => '',
      Type        => 'AdminCc',                             # loc
      Domain      => 'RT::System-Role',
      Instance    => '',
      Description => 'Pseudogroup for internal use',        # loc
    }, );

my @queues = ( {  Name              => 'General',
                  Description       => 'The default queue',
                  CorrespondAddress => "",
                  CommentAddress    => "", }, );

my @ScripActions = (

    {  Name        => 'AutoreplyToRequestors',               # loc
       Description =>
'Always sends a message to the requestors independent of message sender'
       ,                                                     # loc
       ExecModule => 'Autoreply',
       Argument   => 'Requestor' },
    { Name        => 'Notify Requestors',                    # loc
      Description => 'Sends a message to the requestors',    # loc
      ExecModule  => 'Notify',
      Argument    => 'Requestor' },
    { Name        => 'Notify Owner as Comment',              # loc
      Description => 'Sends mail to the owner',              # loc
      ExecModule  => 'NotifyAsComment',
      Argument    => 'Owner' },
    { Name        => 'Notify Owner',                         # loc
      Description => 'Sends mail to the owner',              # loc
      ExecModule  => 'Notify',
      Argument    => 'Owner' },
    { Name        => 'Notify AdminCcs as Comment',                        # loc
      Description => 'Sends mail to the administrative Ccs as a comment', # loc
      ExecModule  => 'NotifyAsComment',
      Argument    => 'AdminCc' },
    { Name        => 'Notify AdminCcs',                                   # loc
      Description => 'Sends mail to the administrative Ccs',              # loc
      ExecModule  => 'Notify',
      Argument    => 'AdminCc' },

    { Name        => 'Notify Requestors and Ccs as Comment',              # loc
      Description => 'Send mail to requestors and Ccs as a comment',      # loc
      ExecModule  => 'NotifyAsComment',
      Argument    => 'Requestor,Cc' },

    { Name        => 'Notify Requestors and Ccs',                         # loc
      Description => 'Send mail to requestors and Ccs',                   # loc
      ExecModule  => 'Notify',
      Argument    => 'Requestor,Cc' },

    { Name        => 'Notify Requestors, Ccs and AdminCcs as Comment',    # loc
      Description => 'Send mail to all watchers as a "comment"',          # loc
      ExecModule  => 'NotifyAsComment',
      Argument    => 'All' },
    { Name        => 'Notify Requestors, Ccs and AdminCcs',               # loc
      Description => 'Send mail to all watchers',                         # loc
      ExecModule  => 'Notify',
      Argument    => 'All' },
    { Name        => 'Notify Other Recipients as Comment',                # loc
      Description => 'Sends mail to explicitly listed Ccs and Bccs',      # loc
      ExecModule  => 'NotifyAsComment',
      Argument    => 'OtherRecipients' },
    { Name        => 'Notify Other Recipients',                           # loc
      Description => 'Sends mail to explicitly listed Ccs and Bccs',      # loc
      ExecModule  => 'Notify',
      Argument    => 'OtherRecipients' },
    { Name        => 'User Defined',                                      # loc
      Description => 'Perform a user-defined action',                     # loc
      ExecModule  => 'UserDefined', },
    {  Name        => 'Create Tickets',                                    # loc
       Description =>
         'Create new tickets based on this scrip\'s template',             # loc
       ExecModule => 'CreateTickets', }, );

my @ScripConditions = (
    { Name                 => 'On Create',                                # loc
      Description          => 'When a ticket is created',                 # loc
      ApplicableTransTypes => 'Create',
      ExecModule           => 'AnyTransaction', },

    { Name                 => 'On Transaction',                           # loc
      Description          => 'When anything happens',                    # loc
      ApplicableTransTypes => 'Any',
      ExecModule           => 'AnyTransaction', },
    {

      Name                 => 'On Correspond',                             # loc
      Description          => 'Whenever correspondence comes in',          # loc
      ApplicableTransTypes => 'Correspond',
      ExecModule           => 'AnyTransaction', },

    {

      Name                 => 'On Comment',                                # loc
      Description          => 'Whenever comments come in',                 # loc
      ApplicableTransTypes => 'Comment',
      ExecModule           => 'AnyTransaction' },
    {

      Name                 => 'On Status Change',                          # loc
      Description          => 'Whenever a ticket\'s status changes',       # loc
      ApplicableTransTypes => 'Status',
      ExecModule           => 'AnyTransaction',

    },
    {

      Name                 => 'On Owner Change',                           # loc
      Description          => 'Whenever a ticket\'s owner changes',        # loc
      ApplicableTransTypes => 'Set',
      ExecModule           => 'OwnerChange',

    },
    {

      Name                 => 'On Queue Change',                           # loc
      Description          => 'Whenever a ticket\'s queue changes',        # loc
      ApplicableTransTypes => 'Set',
      ExecModule           => 'QueueChange',

    },
    {  Name                 => 'On Resolve',                               # loc
       Description          => 'Whenever a ticket is resolved',            # loc
       ApplicableTransTypes => 'Status',
       ExecModule           => 'StatusChange',
       Argument             => 'resolved'

    },

    {  Name                 => 'User Defined',                             # loc
       Description          => 'Whenever a user-defined condition occurs', # loc
       ApplicableTransTypes => 'Any',
       ExecModule           => 'UserDefined'

    }, );

my @templates = (
    { Queue       => '0',
      Name        => 'Blank',                                             # loc
      Description => 'A blank template',                                  # loc
      Content     => '', },
    {  Queue       => '0',
       Name        => 'Autoreply',                                         # loc
       Description => 'Default Autoresponse Template',                     # loc
       Content     => 'Subject: AutoReply: {$Ticket->Subject}


Greetings,

This message has been automatically generated in response to the
creation of a trouble ticket regarding:
	"{$Ticket->Subject()}", 
a summary of which appears below.

There is no need to reply to this message right now.  Your ticket has been
assigned an ID of [{$rtname} #{$Ticket->id()}].

Please include the string:

         [{$rtname} #{$Ticket->id}]

in the subject line of all future correspondence about this issue. To do so, 
you may reply to this message.

                        Thank you,
                        {$Ticket->QueueObj->CorrespondAddress()}

-------------------------------------------------------------------------
{$Transaction->Content()}
'
    },

    {  Queue       => '0',
       Name        => 'Transaction',                     # loc
       Description => 'Default transaction template',    # loc
       Content     => '


{$Transaction->CreatedAsString}: Request {$Ticket->id} was acted upon.
Transaction: {$Transaction->Description}
       Queue: {$Ticket->QueueObj->Name}
     Subject: {$Transaction->Subject || $Ticket->Subject || "(No subject given)"}
       Owner: {$Ticket->OwnerObj->Name}
  Requestors: {$Ticket->RequestorAddresses}
      Status: {$Ticket->Status}
 Ticket <URL: {$RT::WebURL}Ticket/Display.html?id={$Ticket->id} >
-------------------------------------------------------------------------
{$Transaction->Content()}'
    },

    {

      Queue       => '0',
      Name        => 'AdminCorrespondence',                      # loc
      Description => 'Default admin correspondence template',    # loc
      Content     => '


<URL: {$RT::WebURL}Ticket/Display.html?id={$Ticket->id} >

{$Transaction->Content()}'
    },

    {  Queue       => '0',
       Name        => 'Correspondence',                          # loc
       Description => 'Default correspondence template',         # loc
       Content     => '

{$Transaction->Content()}'
    },

    {  Queue       => '0',
       Name        => 'AdminComment',                            # loc
       Description => 'Default admin comment template',          # loc
       Content     =>
'Subject: [Comment] {my $s=($Transaction->Subject||$Ticket->Subject); $s =~ s/\\[Comment\\]//g; $comment =~ s/^Re//i; $s;}


{$RT::WebURL}Ticket/Display.html?id={$Ticket->id}
This is a comment.  It is not sent to the Requestor(s):

{$Transaction->Content()}
'
    },

    {  Queue       => '0',
       Name        => 'StatusChange',                                      # loc
       Description => 'Ticket status changed',                             # loc
       Content     => 'Subject: Status Changed to: {$Transaction->NewValue}


{$RT::WebURL}Ticket/Display.html?id={$Ticket->id}

{$Transaction->Content()}
'
    },

    {

      Queue       => '0',
      Name        => 'Resolved',                 # loc
      Description => 'Ticket Resolved',          # loc
      Content     => 'Subject: Ticket Resolved

According to our records, your request has been resolved. If you have any
further questions or concerns, please respond to this message.
'
    } );

my @acl = (
    { UserId => 'Nobody',                       # - principalId
      Right  => 'OwnTicket', },

    { UserId => 'root',                         # - principalid
      Right  => 'SuperUser', },

);

print "Creating groups...";
foreach $item (@groups) {
    my $new_entry = RT::Group->new($CurrentUser);
    my ( $return, $msg ) = $new_entry->_Create(%$item);
    print "(Error: $msg)" unless ($return);
    print $return. ".";
}
print "done.\n";

print "Creating users...";
foreach $item (@users) {
    my $new_entry = new RT::User($CurrentUser);
    my ( $return, $msg ) = $new_entry->Create(%$item);
    print "(Error: $msg)" unless ($return);
    print $return. ".";
}
print "done.\n";

print "Creating ACL...";
for my $item (@acl) {

    my $princ = RT::User->new($CurrentUser);
    $princ->Load( $item->{'UserId'} );
    my ( $return, $msg ) = $princ->PrincipalObj->GrantRight(
                                                      Right => $item->{'Right'},
                                                      Object => $RT::System );
    if ($return) {
        print $return. ".";
    }
    else {
        print $msg . ".";

    }

}
print "done.\n";

print "Creating queues...";
for $item (@queues) {
    my $new_entry = new RT::Queue($CurrentUser);
    my ( $return, $msg ) = $new_entry->Create(%$item);
    print "(Error: $msg)" unless ($return);
    print $return. ".";
}

print "done.\n";
print "Creating ScripActions...";

for $item (@ScripActions) {
    my $new_entry = RT::ScripAction->new($CurrentUser);
    my $return    = $new_entry->Create(%$item);
    print $return. ".";
}

print "done.\n";
print "Creating ScripConditions...";

for $item (@ScripConditions) {
    my $new_entry = RT::ScripCondition->new($CurrentUser);
    my $return    = $new_entry->Create(%$item);
    print $return. ".";
}

print "done.\n";

print "Creating templates...";

for $item (@templates) {
    my $new_entry = new RT::Template($CurrentUser);
    my $return    = $new_entry->Create(%$item);
    print $return. ".";
}
print "done.\n";

$RT::Handle->Disconnect();


}

=head2 ACLEquivGroupId

Given a userid, return that user's acl equivalence group

=cut

sub ACLEquivGroupId {
    my $username = shift;
    my $user     = RT::User->new($RT::SystemUser);
    $user->Load($username);
    my $equiv_group = RT::Group->new($RT::SystemUser);
    $equiv_group->LoadACLEquivalenceGroup($user);
    return ( $equiv_group->Id );
}
1;
