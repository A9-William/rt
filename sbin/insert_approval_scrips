#!/usr/bin/perl -w
# BEGIN LICENSE BLOCK
# 
# Copyright (c) 1996-2002 Jesse Vincent <jesse@bestpractical.com>
# 
# (Except where explictly superceded by other copyright notices)
# 
# This work is made available to you under the terms of Version 2 of
# the GNU General Public License. A copy of that license should have
# been provided with this software, but in any event can be snarfed
# from www.gnu.org
# 
# This work is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# 
# Unless otherwise specified, all modifications, corrections or
# extensions to this work which alter its source code become the
# property of Best Practical Solutions, LLC when submitted for
# inclusion in the work.
# 
# 
# END LICENSE BLOCK

#
# $Header: /raid/cvsroot/rt/sbin/Attic/insertdata,v 1.1.2.1 2002/01/28 05:27:15 jesse Exp $
# RT is (c) 1996-2002 Jesse Vincent (jesse@bestpractical.com);

use strict;
use vars qw($VERSION $Handle $Nobody $SystemUser $item);

my $ApprovalQueueName = "___Approvals";

use lib "!!RT_LIB_PATH!!";

#This drags in  RT's config.pm
# We do it in a begin block because RT::Handle needs to know the type to do its
# inheritance
BEGIN {
    use RT;
    RT::LoadConfig();
    RT::InitLogging();
}
use Carp;

use RT::User;
use RT::CurrentUser;
use RT::Scrip;
use RT::Template;

#connect to the db
require RT::Handle;
$RT::Handle = RT::Handle->new();
$RT::Handle->Connect();

#Put together a current user object so we can create a User object
my $CurrentUser = new RT::CurrentUser();

#now that we bootstrapped that little bit, we can use the standard RT cli
# helpers  to do what we need

use RT::Interface::CLI qw(CleanEnv GetCurrentUser GetMessageContent);

#Clean out all the nasties from the environment
CleanEnv();

#Load etc/config.pm and drop privs
RT::LoadConfig();

#Connect to the database and get RT::SystemUser and RT::Nobody loaded
RT::Init;

$CurrentUser->LoadByName('RT_System');

# {{{ Queues
my $approvals_queue = RT::Queue->new($CurrentUser);
$approvals_queue->Load($ApprovalQueueName);
unless ($approvals_queue->Id) {
    my ($val, $msg) = $approvals_queue->Create(
        Name        => $ApprovalQueueName,
        Description => 'A system-internal queue for the approvals system',
    );

    unless ($val) {
        warn $msg . "\n";
    }
}

# }}}

# {{{ Scrips

my @scrips = (

    {    # If a ticket in approvals is rejected,
            # reject the original request and attach a reply
            # also, delete all other pending approvals

        Description	       => "If an approval is rejected, reject the original and delete pending approvals",	# loc
        Queue                  => $approvals_queue->Id,
        ScripCondition         => 'User Defined',
        ScripAction            => 'User Defined',
        CustomIsApplicableCode => q[
# ------------------------------------------------------------------- #
if ( $self->TransactionObj->Field eq "Status" &&
	$self->TransactionObj->NewValue eq "Rejected" ) {
    return 1;
}
else {
    return undef
}
# ------------------------------------------------------------------- #
	],
        CustomCommitCode	=> q[
# ------------------------------------------------------------------- #
my $links = $self->TicketObj->DependedOnBy;
while (my $link = $links->Next) {
    my $obj = $link->BaseObj;
    my $pending_approvals = $obj->DependsOn;
    while (my $dependson = $pending_approvals->Next) {
	my $dep = $dependson->TargetObj;
	if ($dep->QueueObj->IsActiveStatus($dep->Status)) {
	    $dep->SetStatus("deleted");
	}
    }
    $obj->Correspond( Content => loc("Your request was rejected") );
    $obj->SetStatus("rejected");
}
# ------------------------------------------------------------------- #
	],
        CustomPrepareCode => '1',
        Template          => 'AdminComment',
    },

    {
        Description	  => "When a ticket has been approved by all approvers, add correspondence to the original ticket", # loc
        Queue             => $approvals_queue->Id,
        ScripCondition    => 'On Resolve',
        CustomPrepareCode => 'return(1);',
        CustomCommitCode  => q[
# ------------------------------------------------------------------- #
# Find all the tickets that depend on this (that this is approving)
my $links = $self->TicketObj->DependedOnBy;
while ( my $link = $links->Next ) {
    # the ticket that depends on this one
    my $obj = $link->BaseObj; 
    next unless ($obj->HasUnresolvedDependencies);
    $obj->Correspond( Content => loc("Your request has been approved.") );
}
return(1);
# ------------------------------------------------------------------- #
	],
        ScripAction => 'User Defined',
        Template    => 'AdminComment',
    },
    {
        Description	  => "When a ticket has been approved by any approver, add correspondence to the original ticket", # loc
        Queue             => $approvals_queue->Id,
        ScripCondition    => 'On Resolve',
        ScripAction       => 'User Defined',
        CustomPrepareCode => 'return(1);',
        CustomCommitCode  => q[
# ------------------------------------------------------------------- #
my $links = $self->TicketObj->DependedOnBy;
while ( my $link = $links->Next ) {
    # the ticket that depends on this one
    my $obj = $link->BaseObj; 
    $obj->Correspond( Content => loc("Your request has been approved by [_1]. Other approvals may still be pending.",$self->TransactionObj->CreatorObj->Name) );
}
return(1);
# ------------------------------------------------------------------- #
	],
        Template => 'AdminComment'
    },
    {
        Description    => "When an approval ticket is created, notify the Owner and AdminCc of the item awaiting their approval", # loc
        Queue          => $approvals_queue->Id,
        ScripCondition => 'On Create',
        ScripAction    => 'Notify AdminCcs',
        Template       => 'New Pending Approval'
    }
);

# }}}

# {{{ Templates
my @templates = (
    {
        Queue       => $approvals_queue->Id,
        Name        => "New Pending Approval", # loc
        Description => "Notify Owners and AdminCcs of new items pending their approval", # loc
        Content     => "Subject: New item pending your approval

There is a new item pending your approval. I have no idea
what autrijus client wants here.
"

    },
    {
	Queue       => '0',
	Name        => 'RootApproval',					# loc
	Description => 'Need approval from system administrator',	# loc
	Content     => << ".",
===Create-Ticket: RootApproval
Subject: {\$Tickets{'TOP'}->Subject}
Depended-On-By: {\$Tickets{'TOP'}->Id}
Queue: ${\($approvals_queue->Id)}
Type: Approval
Owner: root
Content-Type: text/plain
ENDOFCONTENT
.
    },
);

# }}}

print "Creating templates...";

use RT::Template;
for $item (@templates) {
    my $new_entry = RT::Template->new($CurrentUser);
    my $return    = $new_entry->Create(%$item);
    print $return. ".";
}
print "done.\n";

print "Creating scrips...";

use RT::Template;
for $item (@scrips) {
    my $new_entry = RT::Scrip->new($CurrentUser);
    my ($return, $cmsg) = $new_entry->Create(%$item);
    print $return. ".";
    unless ($return) {
        warn $cmsg;

        use Data::Dumper;

        #print scalar Dumper($item);
    }

}
print "done.\n";

$RT::Handle->Disconnect();

1;

