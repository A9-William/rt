<%ONCE>
use Regexp::Common qw(URI);

my %actions = (
    default => sub {
        my %args = @_;
        return $args{value};
    },
    url => sub {
        my %args = @_;
        my $result = qq{[<a target="new" href="$args{value}">}. loc('open URL') .qq{</a>]};
        return $args{value} . qq{ <span class="clickylink">$result</span>};
    },
    url_overwrite => sub {
        my %args = @_;
        my $result = qq{<a target="new" href="$args{'value'}">};
        #XXX: use spaces here. &shy; <wbr> are not well supported :(
        $args{'value'} =~ s/(\S{30})/$1 /g;
        $result .= qq{$args{'value'}</a>};
        return qq{<span class="clickylink">$result</span>};
    },
);

my @types = (
    {
        name   => "httpurl",
        regex  => qr/$RE{URI}{HTTP}{-keep}{-scheme => 'https?'}/,
        action => "url",
    },
    {
        name   => "httpurl_overwrite",
        regex  => qr/$RE{URI}{HTTP}{-keep}{-scheme => 'https?'}/,
        action => "url_overwrite",
    },
);

my $handle = sub {
    my %args = @_;
    for my $rec( @types ) {
        return $rec->{action}->( %args ) if $args{value} =~ $rec->{regex};
    }
};

my $escaper = sub {
    my $content = shift;
    RT::Interface::Web::EscapeUTF8( \$content );
    return $content;
};

# Hook to add more Clicky types
# XXX Have to have Page argument, as Mason gets caller wrong in Callback?
$m->comp("/Elements/Callback", Page => "/Elements/MakeClicky",
    types => \@types,
    actions => \%actions,
    handle => \$handle
);


# Filter
my %active;
$active{$_}++ for RT->Config->Get('Active_MakeClicky');
@types = grep $active{$_->{name}}, @types;

# Build up the whole match
my $regexp = join "|",
             map '\b'. $_->{regex} .'\b',
             @types;

# Make sure we have a default
$actions{default} ||= sub {};

# Anchor the regexes and look up the actions
foreach my $type ( @types ) {
    $type->{regex}  = qr/^$type->{regex}$/;
    $type->{action} = $actions{$type->{action}} || $actions{default};
}

</%ONCE>
<%ARGS>
$content => undef
</%ARGS>
<%INIT>
return unless defined $$content;
unless ( $regexp ) {
    RT::Interface::Web::EscapeUTF8( $content );
    return;
}

my $pos = 0;
while ( $$content =~ /($regexp)/gsio ) {
    my $match = $1;
    my $skipped_len = pos($$content) - $pos - length($match);
    if ( $skipped_len > 0 ) {
        my $plain = $escaper->( substr( $$content, $pos, $skipped_len ) );
        substr( $$content, $pos, $skipped_len ) = $plain;
        $pos += ( $skipped_len = length($plain) );
    }
    {
        my $plain = $handle->( %ARGS, value => $match );
        substr( $$content, $pos, length($match) ) = $plain;
        pos($$content) = ( $pos += length($plain) );
    }
}
substr( $$content, $pos ) = $escaper->( substr( $$content, $pos ) ) unless $pos == length $$content;

</%INIT>
<%doc>

MakeClicky detects various formats of data in headers and email
messages, and extends them with supporting links.  By default, RT
provides two formats:

 * 'httpurl': detects http:// and https:// URLs and adds '[Open URL]'
   link after the URL.

 * 'httpurl_overwrite': also detects URLs as 'httpurl' format, but
   replace URL with link and *adds spaces* into text if it's longer
   then 30 chars. This allow browser to wrap long URLs and avoid
   horizontal scrolling.

To extend this with your own types od data, use the callback.
It will be provided with:

 * 'types': An array reference of hash references.  Modify this array
    reference to add your own types; the first matching type will be
    used.  Each hashref should contain:
   - 'name': The name of the data format; this is used in the
      configuration file to enable the format.
   - 'regex': A regular expression to match against
   - 'action': The name of the action to run (see "actions", below)

 * 'actions': A hash reference of 'actions'.  Modify this hash
    reference to change or add action types.  Values are subroutine
    references which will get called when needed.  They should return
    the modified string. Note that subroutine must escape HTML.

 * 'handler': A reference to a subroutine reference; modify it if you
    have to. This can be used to add pre- or post-processing around
    all actions.

</%doc>
