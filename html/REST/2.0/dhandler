%# The main dispatcher for RT/REST 2.0
<%INIT>
require Digest::MD5;
require MIME::Base64;

# needs discussion on using MD5(pass) as Digest token
@RT::RESTAuthenticationMethods = qw( WSSE Basic )
    unless @RT::RESTAuthenticationMethods;

my $realm = $RT::rtname;
$realm =~ s/[^\w.]//g;
my $nonce = Digest::MD5::md5_hex($realm . rand());
my %methods = map {($_ => 1)} @RT::RESTAuthenticationMethods;

my %accept = map { $_ => 1 } $r->header_in('Accept') =~ m{([^\s,]+/[^;,]+)}g;
my $atom_client = $accept{'application/x.atom+xml'};

my $header_out = sub {
    $ENV{FCGI_ROLE} ? $r->header_out(@_) : $r->headers_out->add(@_);
};

$header_out->(
    'WWW-Authenticate' => qq(WSSE realm="$realm", profile="UsernameToken")
) if $methods{WSSE} and $atom_client;
$header_out->(
    'WWW-Authenticate' => qq(Digest realm="$realm", stale=false, nonce="", qop="auth", algorithm="MD5")
) if $methods{Digest} and !$atom_client;
$header_out->(
    'WWW-Authenticate' => qq(Basic realm="$realm")
) if $methods{Basic} and !$atom_client;

my $CurrentUser;
my $headerParts = sub {
    my $header = $r->header_in($_[0]) || $ENV{$_[0]};
    $header =~ s/^(?:$_[1]) /", / or return;
    $header =~ s/"\s*$//; # strip whitespaces after the last "

    my %parts;
    foreach my $chunk (split /,\s*/, $header) {
	my ($k, $v) = split /=/, $chunk, 2;
	$v =~ s/^"//;
	$v =~ s/"$//;
	$parts{lc($k)} = $v;
    }
    $parts{lc($_)} = delete $parts{$_} for map "$_", keys %parts;
    return \%parts;
};

AUTH_Basic: {
    last if $CurrentUser or !$methods{Basic};

    ($r->header_in('Authorization') || $ENV{'Authorization'})
         =~ /^Basic (.+)$/ or last;
    my ($username, $password) = split(/:/, MIME::Base64::decode_base64($1), 2);

    require RT::CurrentUser;
    $CurrentUser = RT::CurrentUser->new;
    $CurrentUser->Load($username) or last;
    $CurrentUser->IsPassword($password) or undef $CurrentUser;
}

AUTH_Digest: {
    last if $CurrentUser or !$methods{Digest};

    my $parts = $headerParts->('Authorization', 'Digest') or last;

    my ($username, $auth_digest, $auth_nonce,
	$auth_nc, $auth_cnonce, $auth_qop, $auth_uri)
	= map { defined($_) ? $_ : last AUTH_Digest }
	    @{$parts}{qw(username response nonce nc cnonce qop uri)};

    # XXX validate $auth_uri

    require RT::CurrentUser;
    $CurrentUser = RT::CurrentUser->new;
    $CurrentUser->Load($username) or last;

    my $a1 = Digest::MD5::md5_hex(
	"$username:$realm:" . $CurrentUser->UserObj->__Value('Password')
    );

    $auth_digest eq Digest::MD5::md5_hex(
	join(
	    ":", 
	    $a1, $auth_nonce,
	    $auth_nc, $auth_cnonce, $auth_qop,
	    Digest::MD5::md5_hex($r->method . ":" . $auth_uri),
	)
    ) or undef $CurrentUser;
}

AUTH_WSSE: {
    last if $CurrentUser or !$methods{WSSE};
    my $wsse = $headerParts->('X-WSSE', qr/WSSE|UsernameToken/) or last;

    my ($username, $auth_digest, $auth_nonce, $auth_created)
	= map { defined($_) ? $_ : last AUTH_WSSE }
	    @{$wsse}{qw(username passworddigest nonce created)};

    require RT::CurrentUser;
    $CurrentUser = RT::CurrentUser->new;
    $CurrentUser->Load($username) or last;

    # check against reused nonces
    require MIME::Base64;
    $auth_nonce = MIME::Base64::decode_base64($auth_nonce);

    my $nonce_cache;
    require Cache::FileCache;
    $nonce_cache = Cache::FileCache->new({
	namespace => 'RT-Nonces',
	default_expires_in => 1728000,
	auto_purge_interval => 3600,
    });
    $auth_nonce = substr($auth_nonce, 0, 32);
    (undef($CurrentUser), last) if $nonce_cache->get( $auth_nonce );

    # if ($auth_created and abs($auth_created - time) >= 864000) {
    #	last; # system clock differ by more than one day, oops!
    # }

    $CurrentUser->Authenticate(
	$auth_digest, $auth_created, $auth_nonce, $realm
    ) or (undef($CurrentUser), last);

    # remember issued nonces
    $nonce_cache->set( $auth_nonce, 1 );
}

if (!$CurrentUser or !$CurrentUser->Id) {
    return $m->comp('Elements/Error', Status => 401);
}

$session{CurrentUser} = $CurrentUser;

my $verb = {
    GET	    => 'Get',
    HEAD    => 'Get',
    POST    => 'Create',
    PUT	    => 'Put',
    DELETE  => 'Delete',
    OPTIONS => 'Describe',
}->{$r->method} or return $m->comp('Elements/Error', Status => 405);

my $path = $m->dhandler_arg;
my ($type, @parts) = grep length, split('/', $path);

if ($type ne lc($type)) {
    $path =~ s{([^/]*)}{\L$type};
    $r->header_out(Location => $path);
    return $m->comp('Elements/Error', Status => 301);
}

my $adverb = '';
if ($type =~ s/-(\w+)$//) {
    $adverb = $1;
    $verb = 'Describe' if $verb eq 'Get';
    $m->comp('Elements/Error', Status => 405)
        unless $verb =~ /Create|Describe/;
}

if ((@parts % 2) == 0) {
    # FeedURI on collection
    $verb = 'Search' if $verb eq 'Get';
}
elsif ($adverb) {
    # PostURI on object
    $verb = 'Update' if $verb eq 'Create';
}

my $map = $m->comp('Elements/Introspect', Want => 'CollectionToClass');
my $class = $map->{$type};
if ($class) {
    $type = $1 if $class =~ m/([^:]+)$/;
}
else {
    $map = $m->comp('Elements/Introspect', Want => 'RecordToCollection');
    if (my $new_type = lc($map->{$type})) {
	$path =~ s{([^/]*)}{$new_type};
	$r->header_out(Location => $path);
	return $m->comp('Elements/Error', Status => 301);
    }
}

my $BaseURI = "$RT::WebPath/REST/2.0";
$ARGS{Path} = $path;
$ARGS{BaseURI} = $BaseURI;
$ARGS{Link} = "$BaseURI/Elements/Link";
$ARGS{Now} = RT::Date->new($session{CurrentUser});
$ARGS{Now}->SetToNow;

my @types = qw(
    application/x.atom+xml
    application/xhtml+xml
    application/xml
);
my $content_type = 'text/xml'; # fallback
foreach my $try_type (@types) {
    $accept{$try_type} or next;
    $content_type = $try_type;
    last;
}

$r->content_type("$content_type; charset=utf-8");

if (!$class) {
    return $m->comp('index', %ARGS) if $path =~ /index|^\W*$/i;
    return $m->comp('Elements/Error', Status => 404);
}

$m->comp(
    "$verb/index", %ARGS,
    Type => $type,
    Adverb => $adverb,
    CollectionClass => $class,
    FeedURI => "$BaseURI/\L$type",
);
</%INIT>
<%FLAGS>
inherit	=> undef
</%FLAGS>
