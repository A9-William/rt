%# The main dispatcher for RT/REST 2.0
<%INIT>
require Digest::MD5;
require MIME::Base64;

# needs discussion on using MD5(pass) as Digest token
@RT::RESTAuthenticationMethods = qw( WSSE Basic )
    unless @RT::RESTAuthenticationMethods;

my $realm = $RT::rtname;
$realm =~ s/[^\w.]//g;
my $nonce = Digest::MD5::md5_hex($realm . rand());
my %methods = map {($_ => 1)} @RT::RESTAuthenticationMethods;

my $header_out = sub {
    $ENV{FCGI_ROLE} ? $r->header_out(@_) : $r->headers_out->add(@_);
};

$header_out->(
    'WWW-Authenticate' => qq(WSSE realm="$realm", profile="UsernameToken")
) if $methods{WSSE};
$header_out->(
    'WWW-Authenticate' => qq(Digest realm="$realm", stale=false, nonce="", qop="auth", algorithm="MD5")
) if $methods{Digest};
$header_out->(
    'WWW-Authenticate' => qq(Basic realm="$realm")
) if $methods{Basic};

my $CurrentUser;
my $headerParts = sub {
    my $header = $r->header_in($_[0]) || $ENV{$_[0]};
    $header =~ s/^(?:$_[1]) /", / or return;
    $header =~ s/"\s*$//; # strip whitespaces after the last "

    my %parts;
    foreach my $chunk (split /,\s*/, $header) {
	my ($k, $v) = split /=/, $chunk, 2;
	$v =~ s/^"//;
	$v =~ s/"$//;
	$parts{lc($k)} = $v;
    }
    $RT::Logger->error(join(',', %parts));
    $parts{lc($_)} = delete $parts{$_} for map "$_", keys %parts;
    return \%parts;
};

AUTH_Basic: {
    last if $CurrentUser or !$methods{Basic};

    ($r->header_in('Authorization') || $ENV{'Authorization'})
         =~ /^Basic (.+)$/ or last;
    my ($username, $password) = split(/:/, MIME::Base64::decode_base64($1), 2);

    require RT::CurrentUser;
    $CurrentUser = RT::CurrentUser->new;
    $CurrentUser->Load($username) or last;
    $CurrentUser->IsPassword($password) or undef $CurrentUser;
}

AUTH_Digest: {
    last if $CurrentUser or !$methods{Digest};

    my $parts = $headerParts->('Authorization', 'Digest') or last;

    my ($username, $auth_digest, $auth_nonce,
	$auth_nc, $auth_cnonce, $auth_qop, $auth_uri)
	= map { defined($_) ? $_ : last AUTH_Digest }
	    @{$parts}{qw(username response nonce nc cnonce qop uri)};

    # XXX validate $auth_uri

    require RT::CurrentUser;
    $CurrentUser = RT::CurrentUser->new;
    $CurrentUser->Load($username) or last;

    my $a1 = Digest::MD5::md5_hex(
	"$username:$realm:" . $CurrentUser->UserObj->__Value('Password')
    );

    $auth_digest eq Digest::MD5::md5_hex(
	join(
	    ":", 
	    $a1, $auth_nonce,
	    $auth_nc, $auth_cnonce, $auth_qop,
	    Digest::MD5::md5_hex($r->method . ":" . $auth_uri),
	)
    ) or undef $CurrentUser;
}

AUTH_WSSE: {
    last if $CurrentUser or !$methods{WSSE};
    my $wsse = $headerParts->('X-WSSE', qr/WSSE|UsernameToken/) or last;

    my ($username, $auth_digest, $auth_nonce, $auth_created)
	= map { defined($_) ? $_ : last AUTH_WSSE }
	    @{$wsse}{qw(username passworddigest nonce created)};

    require RT::CurrentUser;
    $CurrentUser = RT::CurrentUser->new;
    $CurrentUser->Load($username) or last;

    # check against reused nonces
    my $nonce_cache;
    if ($auth_nonce) {
	require Cache::FileCache;
	$nonce_cache = Cache::FileCache->new({
	    namespace => 'RT-Nonces',
	    default_expires_in => 1728000,
	    auto_purge_interval => 3600,
	});
        $auth_nonce = substr($auth_nonce, 0, 32);
        last if $nonce_cache->get( $auth_nonce );
    }

    # if ($auth_created and abs($auth_created - time) >= 864000) {
    #	last; # system clock differ by more than one day, oops!
    # }

    delete $INC{'RT/CurrentUser.pm'};
    require RT::CurrentUser;

    require MIME::Base64;
    $auth_nonce = MIME::Base64::decode_base64($auth_nonce);

    $CurrentUser->Authenticate(
	$auth_digest, $auth_created, $auth_nonce, $realm
    ) or (undef($CurrentUser), last);

    # remember issued nonces
    $nonce_cache->set( $auth_nonce, 1 );
}

if ($CurrentUser and $CurrentUser->Id) {
    # XXX - do proper delegation goes here

    my $path = $m->dhandler_arg;
    my $type = ucfirst(lc($path));
    $type =~ s{/.*}{};
    $type =~ s{s$}{};

    require "RT/${type}s.pm";
    my $collection = "RT::${type}s"->new($CurrentUser);
    $collection->UnLimit;
    my $count = $collection->Count;

    $r->content_type('text/xml; charset=utf-8');
    my $entries = '';

    my $now = RT::Date->new;
    $now->SetToNow;
    my $modified = $now->W3CDTF;

    while (my $entry = $collection->Next) {
	my %entry = map { $_ => eval { $entry->$_ } || '' }
	    qw(Id Name Description Content);
        $entry{Created} = $entry->CreatedObj->W3CDTF;
        $entry{Created} =~ s/ /T/;
        $entry{LastUpdated} = $entry->LastUpdatedObj->W3CDTF;
        $entry{LastUpdated} =~ s/ /T/;
    
	$entries .= <<".";
  <entry>
    <title mode="escaped">$entry{Name}</title>
    <link rel="alternate" type="text/html" href="$RT::WebPath/$type/Display.html?id=$entry{Id}"/>
    <modified>$entry{LastUpdated}</modified>
    <issued>$entry{Created}</issued>
    <created>$entry{Created}</created>
    <id>rt-fsck.com:$RT::rtname/$entry{Id}</id>
    <summary mode="escaped">$entry{Description}</summary>
    <content type="text/plain" mode="escaped" xml:base="http://diveintomark.org/archives/2004/04/19/feed-parser-beta-22">
      <![CDATA[$entry{Content}]]>
    </content>
  </entry>
.
    }
    print << ".";
<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/css" href="$RT::WebPath/REST/2.0/NoAuth/feed.css"?>
<feed version="0.3" xmlns="http://purl.org/atom/ns#">
  <title>\u$type search results</title>
  <author>
    <name>$RT::Organization</name>
    <url>$RT::WebURL</url>
  </author>
  <link rel="alternate" type="text/html" href="$RT::WebURL"/>
  <tagline mode="escaped">$count results found.</tagline>
  <id>rt-fsck.com://$path</id>
  <modified>$modified</modified>
  <generator url="http://www.bestpractical.com/rt/" version="$RT::VERSION">RT</generator>
  $entries
</feed>
.
}
else {
    $r->status(401);
}

</%INIT>
<%FLAGS>
inherit	=> undef
</%FLAGS>
