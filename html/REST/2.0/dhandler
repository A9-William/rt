%# The main dispatcher for RT/REST 2.0
<%INIT>
require Digest::MD5;
require MIME::Base64;

# needs discussion on using MD5(pass) as Digest token
@RT::RESTAuthenticationMethods = qw( WSSE Basic )
    unless @RT::RESTAuthenticationMethods;

my $realm = $RT::rtname;
$realm =~ s/[^\w.]//g;
my $nonce = Digest::MD5::md5_hex($realm . rand());
my %methods = map {($_ => 1)} @RT::RESTAuthenticationMethods;

my $atom_client = ($r->header_in('User-Agent') =~ /\batom\b/i);
my $header_out = sub {
    $ENV{FCGI_ROLE} ? $r->header_out(@_) : $r->headers_out->add(@_);
};

$header_out->(
    'WWW-Authenticate' => qq(WSSE realm="$realm", profile="UsernameToken")
) if $methods{WSSE} and $atom_client;
$header_out->(
    'WWW-Authenticate' => qq(Digest realm="$realm", stale=false, nonce="", qop="auth", algorithm="MD5")
) if $methods{Digest} and !$atom_client;
$header_out->(
    'WWW-Authenticate' => qq(Basic realm="$realm")
) if $methods{Basic} and !$atom_client;

my $CurrentUser;
my $headerParts = sub {
    my $header = $r->header_in($_[0]) || $ENV{$_[0]};
    $header =~ s/^(?:$_[1]) /", / or return;
    $header =~ s/"\s*$//; # strip whitespaces after the last "

    my %parts;
    foreach my $chunk (split /,\s*/, $header) {
	my ($k, $v) = split /=/, $chunk, 2;
	$v =~ s/^"//;
	$v =~ s/"$//;
	$parts{lc($k)} = $v;
    }
    $RT::Logger->error(join(',', %parts));
    $parts{lc($_)} = delete $parts{$_} for map "$_", keys %parts;
    return \%parts;
};

AUTH_Basic: {
    last if $CurrentUser or !$methods{Basic};

    ($r->header_in('Authorization') || $ENV{'Authorization'})
         =~ /^Basic (.+)$/ or last;
    my ($username, $password) = split(/:/, MIME::Base64::decode_base64($1), 2);

    require RT::CurrentUser;
    $CurrentUser = RT::CurrentUser->new;
    $CurrentUser->Load($username) or last;
    $CurrentUser->IsPassword($password) or undef $CurrentUser;
}

AUTH_Digest: {
    last if $CurrentUser or !$methods{Digest};

    my $parts = $headerParts->('Authorization', 'Digest') or last;

    my ($username, $auth_digest, $auth_nonce,
	$auth_nc, $auth_cnonce, $auth_qop, $auth_uri)
	= map { defined($_) ? $_ : last AUTH_Digest }
	    @{$parts}{qw(username response nonce nc cnonce qop uri)};

    # XXX validate $auth_uri

    require RT::CurrentUser;
    $CurrentUser = RT::CurrentUser->new;
    $CurrentUser->Load($username) or last;

    my $a1 = Digest::MD5::md5_hex(
	"$username:$realm:" . $CurrentUser->UserObj->__Value('Password')
    );

    $auth_digest eq Digest::MD5::md5_hex(
	join(
	    ":", 
	    $a1, $auth_nonce,
	    $auth_nc, $auth_cnonce, $auth_qop,
	    Digest::MD5::md5_hex($r->method . ":" . $auth_uri),
	)
    ) or undef $CurrentUser;
}

AUTH_WSSE: {
    last if $CurrentUser or !$methods{WSSE};
    my $wsse = $headerParts->('X-WSSE', qr/WSSE|UsernameToken/) or last;

    my ($username, $auth_digest, $auth_nonce, $auth_created)
	= map { defined($_) ? $_ : last AUTH_WSSE }
	    @{$wsse}{qw(username passworddigest nonce created)};

    require RT::CurrentUser;
    $CurrentUser = RT::CurrentUser->new;
    $CurrentUser->Load($username) or last;

    # check against reused nonces
    my $nonce_cache;
    if ($auth_nonce) {
	require Cache::FileCache;
	$nonce_cache = Cache::FileCache->new({
	    namespace => 'RT-Nonces',
	    default_expires_in => 1728000,
	    auto_purge_interval => 3600,
	});
        $auth_nonce = substr($auth_nonce, 0, 32);
        last if $nonce_cache->get( $auth_nonce );
    }

    # if ($auth_created and abs($auth_created - time) >= 864000) {
    #	last; # system clock differ by more than one day, oops!
    # }

    require MIME::Base64;
    $auth_nonce = MIME::Base64::decode_base64($auth_nonce);

    $CurrentUser->Authenticate(
	$auth_digest, $auth_created, $auth_nonce, $realm
    ) or (undef($CurrentUser), last);

    # remember issued nonces
    $nonce_cache->set( $auth_nonce, 1 );
}

if (!$CurrentUser or !$CurrentUser->Id) {
    $m->comp('Error/index', Status => 401);
}

$session{CurrentUser} = $CurrentUser;

# TODO: Redirect /template to /templates

my $path = $m->dhandler_arg;
my $type = lc($path);
$type =~ s{/.*}{};
$type =~ s{-}{/};

my $class;
foreach my $key (keys %INC) {
    $key =~ m{^RTx?(?:/.+)?/($type).pm}i or next;
    $type = $1;
    $class = $key;
    $class =~ s{.pm$}{}i;
    $class =~ s{/}{::}g;
    $class->can('UnLimit') or (undef $class, next);
    last;
}

if (!$class) {
    return $m->comp('index') if $path =~ /index|^\W*$/i;
    return $m->comp('Error/index', Status => 404);
}

$m->comp(
    'Search/index', %ARGS,
    Path => $path,
    Type => $type,
    CollectionClass => $class,
);
</%INIT>
<%FLAGS>
inherit	=> undef
</%FLAGS>
