%# BEGIN LICENSE BLOCK
%# 
%# Copyright (c) 1996-2003 Jesse Vincent <jesse@bestpractical.com>
%# 
%# (Except where explictly superceded by other copyright notices)
%# 
%# This work is made available to you under the terms of Version 2 of
%# the GNU General Public License. A copy of that license should have
%# been provided with this software, but in any event can be snarfed
%# from www.gnu.org.
%# 
%# This work is distributed in the hope that it will be useful, but
%# WITHOUT ANY WARRANTY; without even the implied warranty of
%# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
%# General Public License for more details.
%# 
%# Unless otherwise specified, all modifications, corrections or
%# extensions to this work which alter its source code become the
%# property of Best Practical Solutions, LLC when submitted for
%# inclusion in the work.
%# 
%# 
%# END LICENSE BLOCK
<& /Elements/Header, Title => $title &>
<& /Ticket/Elements/Tabs, 
    current_tab => "Search/Build.html".$QueryString, 
    Title => $title, Format => $Format,
    Query => $Query,
    Rows => $ARGS{'Rows'},
&>

<table width=100%>
<tr>
<td valign=top class="boxcontainer">
<FORM METHOD="POST" ACTION="Build.html" NAME="BuildQuery">
<input type=hidden name=SearchId value="<%$ARGS{'SearchId'}%>">
<input type=hidden name=Query value="<%$Query%>">
<input type=hidden name=Format value="<%$Format%>">
<& Elements/PickCriteria, query => $Query, cfqueues => \%queues, %ARGS &>
<& /Elements/Submit, Caption => "Add additional criteria", Label => loc('Add'), Name => 'AddClause'&>

</td>
<td valign=top class="boxcontainer">
<& /Elements/TitleBoxStart, title => loc("Query") . ": " .$search_hash->{'Description'} &>
<& Elements/NewListActions, actions => \@actions &>
<select size=10 name=clauses style="width : 100%">
<%$optionlist|n%>
</select>
<center>
<input type=submit name="Up" value="^">
<input type=submit name="Down" value="v">
<input type=submit name="Left" value="<">
<input type=submit name="Right" value=">">
<input type=submit name="DeleteClause" value="Delete">
<br>
<input type=submit name="Clear" value="Clear">
<input type=submit name="Toggle" value="And/Or">
%#<input type=submit name="EditQuery" value="Advanced">
</center>
<& /Elements/TitleBoxEnd &>
</form>
<br>
<FORM METHOD="POST" ACTION="Build.html" NAME="SavedSearch">
<input type=hidden name=Query value="<%$Query%>">
<input type=hidden name=Format value="<%$Format%>">
<& Elements/EditSearches, CurrentSearch => $search_hash &>
</FORM>
</td>
</tr>
<tr>
<td colspan=2 class="boxcontainer">

<FORM METHOD="POST" ACTION="Build.html" NAME="EditFormat">
<input type=hidden name=Query value="<%$Query%>">
<input type=hidden name=Format value="<%$Format%>">
<input type=hidden name=SearchId value="<%$ARGS{'SearchId'}%>">
<& Elements/DisplayOptions, Format=> ($Format||$search_hash->{'Format'}),
AvailableColumns => $AvailableColumns,  CurrentFormat => $CurrentFormat, %ARGS &>
</FORM>
</td>
</tr>
</table>

<%INIT>
use Tree::Simple;

my $search_hash = {};
my $search;
my $title = loc("Query Builder");

if ($NewQuery) {
    $Query = '';
    $Format = '';
    $Description = '';
    undef $session{'CurrentSearchHash'};
    $session{'tickets'}->CleanSlate() if defined $session{'tickets'};
} else {
    $search_hash = $session{'CurrentSearchHash'};
    $Query ||= $search_hash->{'Query'};
    $Format ||= $search_hash->{'Format'};
    $Description ||= $search_hash->{'Description'};
}

my @actions        = ();
my %queues;

$ARGS{'Format'} = $Format = $m->comp('/Elements/ScrubHTML', Content => $Format) if ($Format);

if ( $ARGS{"DoSearch"} ) {
    $m->comp( "Results.html", Query   => $Query, Format  => $Format, OrderBy => $ARGS{OrderBy}, Rows    => $ARGS{RowsPerPage});
    $m->abort();
}

# If the user wants a new search, clobber the search id
if ( $ARGS{'CopySearch'} ) {
    $ARGS{'SearchId'} = 'new';
}

# {{{ if we're asked to revert the current search, we just want to load it
if ( $ARGS{'Revert'} ) {
    $ARGS{'LoadSavedSearch'} = $ARGS{'SearchId'};
    $Format                  = undef;
    $Query                   = undef;
}

# }}}

# {{{ if we're asked to load a search, load it.
if ( $ARGS{'LoadSavedSearch'} =~ /^(.*?)-(\d+)-SavedSearch-(\d+)$/ ) {
    my $obj_type  = $1;
    my $obj_id    = $2;
    my $search_id = $3;

    # We explicitly list out the available types and
    # don't trust user input here
    if (   ( $obj_type eq 'RT::User' ) && ( $obj_id == $session{'CurrentUser'}->id ) ) {
        $search = $session{'CurrentUser'}->UserObj->Attributes->WithId($search_id);

    }
    elsif ($obj_type eq 'RT::Group')  {
        my $group = RT::Group->new($session{'CurrentUser'});
        $group->Load($obj_id);
        $search = $group->Attributes->WithId($search_id);
    }



    $search_hash->{'SearchId'} = $ARGS{'LoadSavedSearch'};
    $ARGS{'Format'} = $Format   = $search->SubValue('Format');
    $ARGS{'Query'} = $Query    = $search->SubValue('Query');
    $SearchId = $ARGS{'LoadSavedSearch'};


}

# }}}

# if we've gotten to this point, without a $search, the user is doing _something_ other than
# manipulating a search's saved status. whcih means we don't have a loaded
# saved search.
# we want to load the search they're working on and compare it to the currently
# loaded search. this will let us present the right buttons.

if ( !$search && $ARGS{'SearchId'} =~ /^(.*?)-(\d+)-SavedSearch-(\d+)$/ ) {
    my $obj_type  = $1;
    my $obj_id    = $2;
    my $search_id = $3;

    # XXX TODO This will only let users save personal searches
    # We explicitly list out the available types and
    # don't trust user input here
    if (   ( $obj_type eq 'RT::User' ) && ( $obj_id == $session{'CurrentUser'}->id ) ) {
        $search = $session{'CurrentUser'}->UserObj->Attributes->WithId($search_id);
        $search_hash->{'SearchId'} = $ARGS{'SearchId'};

    }
    elsif ($obj_type eq 'RT::Group')  {
        my $group = RT::Group->new($session{'CurrentUser'});
        $group->Load($obj_id);
        $search = $group->Attributes->WithId($search_id);
        $search_hash->{'SearchId'} = $ARGS{'SearchId'};
    }



    else {
        push @actions, [loc("Searches can't be associated with that kind of object"), 0];
    }

}

if ($search) {
    $search_hash->{Description} = ( $search->Description() || loc('Untitled search') );
    $search_hash->{Format}   = $search->SubValue('Format');
    $search_hash->{Query}    = $search->SubValue('Query');
    $search_hash->{Object} = $search;
}
else {
    $search_hash->{Description} = loc('Untitled search');
    $search_hash->{Format}      = '';
    $search_hash->{Query}       = '';
}


# {{{ Parse the query
my $tree;
ParseQuery( $Query, \$tree, \@actions );

# if parsing went poorly, send them to the edit page to fix it
if ( $actions[0] ) {
    $m->comp( "Edit.html", Query => $Query, actions => \@actions );
    $m->abort();
}

my @options;
my $optionlist;
$Query  = "";
%queues = ();

$optionlist = build_array( \$Query, $ARGS{clauses}, $tree, \@options, \%queues );

my $currentkey;
$currentkey = $options[$ARGS{clauses}] if defined $ARGS{clauses};

# We can't check for the addclause button because hitting return in
# a criterion will get lost otherwise
if (1) {

    foreach my $arg ( keys %ARGS ) {
        if ( $arg =~ m/ValueOf(.+)/ && $ARGS{$arg} ) {
            my $field = $1;
            my $keyword;

            #figure out if it's a grouping
            if ( $ARGS{ $field . "Field" } ) {
                $keyword = $ARGS{ $field . "Field" };
            }
           else {
                $keyword = $field;
            }
            my $clause = {
                Key   => $keyword,
                Op    => $ARGS{ $field . 'Op' },
                Value => "'$ARGS{'ValueOf' . $field}'"
            };

	    my $newnode = Tree::Simple->new($clause);
	    if ($currentkey) {
		my $newindex = $currentkey->getIndex() + 1;
		if ($currentkey->getParent()->getParent()->isRoot()) {
		    my $newparent = Tree::Simple->new($ARGS{'AndOr'});
		    $newparent->addChild($newnode);
		    $newnode = $newparent;
		} else {
		    $currentkey->getParent()->setNodeValue($ARGS{'AndOr'});
		}
		$currentkey->insertSibling($newindex, $newnode);
		$currentkey = $newnode;
	    } else {
		my $newparent = Tree::Simple->new($ARGS{'AndOr'});
		$newparent->addChild($newnode);
		$tree->getChild(0)->addChild($newparent);
		$currentkey = $newparent;
	    }
	}
    }
}

# {{{ Move things around
if ( $ARGS{"Up"} ) {
    if ($currentkey) {
	my $index = $currentkey->getIndex();
	if ( $currentkey->getIndex() > 0 ) {
	    my $parent = $currentkey->getParent();
	    $parent->removeChild($index);
	    $parent->insertChild($index - 1, $currentkey);
	    $currentkey = $parent->getChild($index - 1);
	}
        else {
            push( @actions, [ "error: can't move up", -1 ] );
        }
    }
    else {
        push( @actions, [ "error: nothing to move", -1 ] );
    }
}
elsif ( $ARGS{"Down"} ) {
    if ($currentkey) {
	my $index = $currentkey->getIndex();
	my $parent = $currentkey->getParent();
	if ( $currentkey->getIndex() < ($parent->getChildCount - 1) ) {
	    $parent->removeChild($index);
	    $parent->insertChild($index + 1, $currentkey);
	    $currentkey = $parent->getChild($index + 1);
	}
        else {
            push( @actions, [ "error: can't move down", -1 ] );
        }
    }
    else {
        push( @actions, [ "error: nothing to move", -1 ] );
    }
}
elsif ( $ARGS{"Left"} ) {
    if ($currentkey) {
	my $parent = $currentkey->getParent();
	my $grandparent = $parent->getParent();
	if (!$grandparent->isRoot) {
	    my $index = $parent->getIndex();
	    $parent->removeChild($currentkey);
	    $grandparent->insertChild($index, $currentkey);
	    if ($parent->isLeaf()) {
		$grandparent->removeChild($parent);
	    }
        }
        else {
            push( @actions, [ "error: can't move left", -1 ] );
        }
    }
    else {
        push( @actions, [ "error: nothing to move", -1 ] );
    }
}
elsif ( $ARGS{"Right"} ) {
    if ($currentkey) {
	my $parent = $currentkey->getParent();
	my $index = $currentkey->getIndex();
	my $newparent;
	if ($index > 0 ) {
	    my $sibling = $parent->getChild($index - 1);
	    if (ref($sibling->getNodeValue)) {
		$parent->removeChild($currentkey);
		my $newtree = Tree::Simple->new('AND', $parent);
		$newtree->addChild($currentkey);
	    } else {
		$parent->removeChild($index);
		$sibling->addChild($currentkey);
	    }
	}
	else {
	    $parent->removeChild($currentkey);
	    $newparent = Tree::Simple->new('AND', $parent);
	    $newparent->addChild($currentkey);
	}
    } else {
        push( @actions, [ "error: nothing to move", -1 ] );
    }
}
elsif ( $ARGS{"DeleteClause"} ) {
    if ($currentkey) {
	$currentkey->getParent()->removeChild($currentkey);
    }
    else {
        push( @actions, [ "error: nothing to delete", -1 ] );
    }
}
elsif ( $ARGS{"Toggle"} ) {
    my $ea;
    if ($currentkey) {
	my $value = $currentkey->getNodeValue();
	my $parent = $currentkey->getParent();
	my $parentvalue = $parent->getNodeValue();
	if (ref($value)) {
	    if ( $parentvalue eq 'AND') {
		$parent->setNodeValue('OR');
	    } else {
		$parent->setNodeValue('AND');
	    }
	} else {
	    if ($value eq 'AND') {
		$currentkey->setNodeValue('OR');
	    } else {
		$currentkey->setNodeValue('AND');
	    }
	}
    }
    else {
        push( @actions, [ "error: nothing to toggle", -1 ] );
    }
}
elsif ( $ARGS{"Clear"} ) {
    $tree = Tree::Simple->new(Tree::Simple->ROOT);
}

# }}}
# {{{ Query building magic

$Query   = "";
@options = ();
%queues  = ();
$optionlist = build_array( \$Query, $currentkey, $tree, \@options, \%queues );

sub build_array {
    my $Query     = shift;
    my $currentkey = shift;
    my $tree = shift;
    my ($keys, $queues)    = @_;
    my $i = 0;
    my $optionlist;
    my $depth = 0;
    my %parens;

    $tree->traverse(
    sub {
    my ($_tree) = @_;

    return if $_tree->getParent->isRoot();

    push @$keys, $_tree;
    my $clause = $_tree->getNodeValue();
    my $str;
    my $ea = $_tree->getParent()->getNodeValue();
    if (ref($clause)) {
        $str .= $ea . " " if $_tree->getIndex() > 0;
	$str .= $clause->{Key} . " " . $clause->{Op} . " " . $clause->{Value};

	if ( $clause->{Key} eq "Queue" ) {
	    $queues->{ $clause->{Value} } = 1;
	}
    } else {
	$str = $ea if $_tree->getIndex() > 0;
    }

    my $selected;
    if ($_tree == $currentkey) {
	$selected = "SELECTED";
    }
    else {
	$selected = "";
    }

    foreach my $p (keys %parens) {
	if ($p > $_tree->getDepth) {
	    $$Query .= ')' x $parens{$p};
	    $parens{$p}--;
	}
    }

    $optionlist .= "<option value=$i $selected>" .
	("&nbsp;" x 5 x ($_tree->getDepth() - 1)) . "$str</option>\n";
    my $parent = $_tree->getParent();
    if (!($parent->isRoot || $parent->getParent()->isRoot) &&
	!ref($parent->getNodeValue())) {
	if ( $_tree->getIndex() == 0) {
	    $$Query .= '(';
	    $parens{$_tree->getDepth}++;
	}
    }
    $$Query .= " " . $str . " ";

    if ($_tree->getDepth < $depth) {
	$$Query .= ')';
	$parens{$depth}--;
    }

    $i++;
}
);

foreach my $p (keys %parens) {
    $$Query .= ") " x $parens{$p};
}

return $optionlist;

}

use Regexp::Common qw /delimited/;

# States
use constant VALUE   => 1;
use constant AGGREG  => 2;
use constant OP      => 4;
use constant PAREN   => 8;
use constant KEYWORD => 16;

sub ParseQuery {
    my $string = shift;
    my $tree = shift;
    my @actions = shift;
    my $want   = KEYWORD | PAREN;
    my $last   = undef;

    my $depth = 1;

    # make a tree root
    $$tree = Tree::Simple->new(Tree::Simple->ROOT);
    my $root = Tree::Simple->new('AND', $$tree);
    my $lastnode = $root;
    my $parentnode = $root;

    # get the FIELDS from Tickets_Overlay
    my $tickets = new RT::Tickets( $session{'CurrentUser'} );
    my %FIELDS  = %{ $tickets->FIELDS };

    # Lower Case version of FIELDS, for case insensitivity
    my %lcfields = map { ( lc($_) => $_ ) } ( keys %FIELDS );

    my @tokens     = qw[VALUE AGGREG OP PAREN KEYWORD];
    my $re_aggreg  = qr[(?i:AND|OR)];
    my $re_value   = qr[$RE{delimited}{-delim=>qq{\'\"}}|\d+];
    my $re_keyword = qr[$RE{delimited}{-delim=>qq{\'\"}}|(?:\{|\}|\w|\.)+];
    my $re_op      = qr[=|!=|>=|<=|>|<|(?i:IS NOT)|(?i:IS)|(?i:NOT LIKE)|(?i:LIKE)] ;    # long to short
    my $re_paren = qr'\(|\)';

    # assume that $ea is AND if it's not set
    my ( $ea, $key, $op, $value ) = ( "AND", "", "", "" );

    # order of matches in the RE is important.. op should come early,
    # because it has spaces in it.  otherwise "NOT LIKE" might be parsed
    # as a keyword or value.

    while ( $string =~ /(
                      $re_aggreg
                      |$re_op
                      |$re_keyword
                      |$re_value
                      |$re_paren
                     )/igx
      )
    {
        my $val     = $1;
        my $current = 0;

        # Highest priority is last
        $current = OP    if _match( $re_op,    $val );
        $current = VALUE if _match( $re_value, $val );
        $current = KEYWORD
          if _match( $re_keyword, $val ) && ( $want & KEYWORD );
        $current = AGGREG if _match( $re_aggreg, $val );
        $current = PAREN  if _match( $re_paren,  $val );

        unless ( $current && $want & $current ) {

            # Error
            # FIXME: I will only print out the highest $want value
            my $token = $tokens[ ( ( log $want ) / ( log 2 ) ) ];
            push @actions, [ "current: $current, want $want, Error near ->$val<- expecting a " . $token . " in '$string'\n", -1 ];
        }

        # State Machine:
        my $parentdepth = $depth;

        # Parens are highest priority
        if ( $current & PAREN ) {
            if ( $val eq "(" ) {
		$depth++;
		# make a new node that the clauses can be children of
		$parentnode = Tree::Simple->new($ea, $parentnode);
            }
            else {
		$depth--;
		$parentnode = $parentnode->getParent();
		$lastnode = $parentnode;
            }

            $want = KEYWORD | PAREN | AGGREG;
        }
        elsif ( $current & AGGREG ) {
            $ea = $val;
            $want = KEYWORD | PAREN;
        }
        elsif ( $current & KEYWORD ) {
            $key  = $val;
            $want = OP;
        }
        elsif ( $current & OP ) {
            $op   = $val;
            $want = VALUE;
        }
        elsif ( $current & VALUE ) {
            $value = $val;

            # Remove surrounding quotes from $key, $val
            # (in future, simplify as for($key,$val) { action on $_ })
            if ( $key =~ /$RE{delimited}{-delim=>qq{\'\"}}/ ) {
                substr( $key, 0,  1 ) = "";
                substr( $key, -1, 1 ) = "";
            }
            if ( $val =~ /$RE{delimited}{-delim=>qq{\'\"}}/ ) {
                substr( $val, 0,  1 ) = "";
                substr( $val, -1, 1 ) = "";
            }

            # Unescape escaped characters
            $key =~ s!\\(.)!$1!g;
            $val =~ s!\\(.)!$1!g;

            my $class;
            if ( exists $lcfields{ lc $key } ) {
                $key   = $lcfields{ lc $key };
                $class = $FIELDS{$key}->[0];
            }
            if ( $class ne 'INT' ) {
                $val = "'$val'";
            }

            push @actions, [ "Unknown field: $key", -1 ] unless $class;

            $want = PAREN | AGGREG;
        }
        else {
            push @actions, [ "I'm lost", -1 ];
        }

        if ( $current & VALUE ) {
	    if ( $key =~ /^CF./ ) {
	        $key = "'" . $key . "'";
	    }
            my $clause = {
                Key   => $key,
                Op    => $op,
                Value => $val
            };

	    # explicity add a child to it
	    $lastnode = Tree::Simple->new($clause, $parentnode);
	    $lastnode->getParent()->setNodeValue($ea);

            ( $ea, $key, $op, $value ) = ( "", "", "", "" );
        }

        $last = $current;
    }    # while

    push @actions, [ "Incomplete query", -1 ]
      unless ( ( $want | PAREN ) || ( $want | KEYWORD ) );

    push @actions, [ "Incomplete Query", -1 ]
      unless ( $last && ( $last | PAREN ) || ( $last || VALUE ) );

    # This will never happen, because the parser will complain
    push @actions, [ "Mismatched parentheses", -1 ]
      unless $depth == 1;
}

sub _match {

    # Case insensitive equality
    my ( $y, $x ) = @_;
    return 1 if $x =~ /^$y$/i;

    #  return 1 if ((lc $x) eq (lc $y)); # Why isnt this equiv?
    return 0;
}

sub debug {
    my $message = shift;
    $m->print($message . "<br>");
}

# }}}

# }}}

# {{{ Deal with format changes
my ($AvailableColumns, $CurrentFormat);
($Format, $AvailableColumns, $CurrentFormat) = $m->comp('Elements/BuildFormatString', cfqueues => \%queues, %ARGS);

$ARGS{'Format'} = $Format;
$ARGS{'Query'}  = $Query;

# }}}

# {{{ if we're asked to save the current search, save it
if ( $ARGS{'Save'} ) {

        if ($search && $search->id) {

        # if the search data or metadata has changed, change it
        $search->SetSubValues(
            Format => $ARGS{'Format'},
            Query  => $ARGS{'Query'}
        );
        $search->SetDescription( $ARGS{'Description'} );

        # if the associated object has changed, change which object this search
        # applies to

        $search_hash->{'SearchId'} = $ARGS{'SearchId'};
        $search_hash->{'Object'}   = $search;
        $search_hash->{'Format'} = $ARGS{'Format'};
        $search_hash->{'Query'} = $ARGS{'Query'};
        $search_hash->{'Description'} = $ARGS{'Description'};

    }
    elsif ( $ARGS{'SearchId'} eq 'new' && $ARGS{'Owner'} =~ /^(.*?)-(\d+)$/ ) {
    my $obj_type  = $1;
    my $obj_id    = $2;
 

        my $container_object;
        if ( $obj_type eq 'RT::User' && $obj_id == $session{'CurrentUser'}->Id)  {
            $container_object =    $session{'CurrentUser'}->UserObj;
        }
        elsif ($obj_type eq 'RT::Group') {
            $container_object = RT::Group->new($session{'CurrentUser'});
            $container_object->Load($obj_id);
        }

        if ($container_object->id ) { 

        
        my ( $search_id, $search_msg ) = $container_object->AddAttribute(
            Name        => 'SavedSearch',
            Description => $ARGS{'Description'},
            Content     => {
                Format => $ARGS{'Format'},
                Query  => $Query
            }
          );
        $search = $session{'CurrentUser'}->UserObj->Attributes->WithId($search_id);
        $search_hash->{'SearchId'} = ref( $session{'CurrentUser'}->UserObj ) . '-'
          . $session{'CurrentUser'}->UserObj->Id . '-SavedSearch-' . $search->Id;
    }
        unless ($search->id) {
            push @actions, [loc("Can't find a saved search to work with"), 0];
        }

    $search_hash->{Description} = ( $search->Description() || loc('Untitled search') );
    $search_hash->{Format}   = $search->SubValue('Format');
    $search_hash->{Query}    = $search->SubValue('Query');
    $search_hash->{Object} = $search;
    }

    else {
            push @actions, [loc("Can't save this search"), 0];
    }

}

# }}}

# {{{ If we're asked to delete the current search, make it go away and reset
# the search parameters
if ( $ARGS{'Delete'} ) {
    if ( $ARGS{'SearchId'} =~ /^(.*?)-(\d+)-SavedSearch-(\d+)$/ ) {
        my $obj_type  = $1;
        my $obj_id    = $2;
        my $search_id = $3;

        my $container_object;
        if ( $obj_type eq 'RT::User' && $obj_id == $session{'CurrentUser'}->Id)  {
            $container_object =    $session{'CurrentUser'}->UserObj;
        }
        elsif ($obj_type eq 'RT::Group') {
            $container_object = RT::Group->new($session{'CurrentUser'});
            $container_object->Load($obj_id);
        }

        if ($container_object->id ) { 

        $container_object->Attributes->DeleteEntry( Name => 'SavedSearch', id   => $search_id);

        $Format = '';
        $Query  = '';

    }

    delete $ARGS{'SearchId'};
    }
}

# }}}

# Build a querystring for the tabs

my $QueryString;
if ($NewQuery) {
    $QueryString = '?NewQuery=1';
} else {
    $QueryString = '?' . $m->comp('/Elements/QueryString', 
            Query => $Query,
	    Format => $Format,
	    Rows =>$ARGS{'Rows'}) if ($Query);
}

if (!$search) {
    $search_hash->{'SearchId'} = $SearchId;
    $search_hash->{'Format'} = $Format;
    $search_hash->{'Query'} = $Query;
    $search_hash->{'Description'} = $Description || $ARGS{'Descripton'};
}

$session{'CurrentSearchHash'} = $search_hash;

$ARGS{'SearchId'} =$search_hash->{'SearchId'};
</%INIT>

<%ARGS>
$NewQuery => 0
$SearchId => 'new'
$Query => undef
$Format => undef 
$Description => undef
$HideResults => 0
</%ARGS>
