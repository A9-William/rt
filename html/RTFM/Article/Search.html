%# BEGIN LICENSE BLOCK
%# 
%#  Copyright (c) 2002-2003 Jesse Vincent <jesse@bestpractical.com>
%#  
%#  This program is free software; you can redistribute it and/or modify
%#  it under the terms of version 2 of the GNU General Public License 
%#  as published by the Free Software Foundation.
%# 
%#  A copy of that license should have arrived with this
%#  software, but in any event can be snarfed from www.gnu.org.
%# 
%#  This program is distributed in the hope that it will be useful,
%#  but WITHOUT ANY WARRANTY; without even the implied warranty of
%#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%#  GNU General Public License for more details.
%# 
%# END LICENSE BLOCK

<& /RTFM/Article/Elements/Tabs, current_tab => "RTFM/Article/Search.html", Title => loc("Search for articles") &>
<& /Elements/ListActions, actions => \@results &>
<& Elements/ShowSearchResults, articles => $articles &>

<form action="Search.html" method="GET">
<& Elements/ShowSavedSearches, CurrentSearch => $CurrentSearch, 
    Description => ($search ? $search->Name : undef) &>
<& Elements/ShowSearchCriteria, dates => \%dates, RefersTo => $RefersTo, customfields => $customfields,  ReferredToBy => $ReferredToBy, %ARGS &>
<%init>
use RT::SavedSearch;
my @results;
my $articles = RT::FM::ArticleCollection->new( $session{'CurrentUser'} );


# {{{ Saved search logic

my $search;

# The keys that are not saved and loaded with named searches.  These
# need to be treated specially.
my @metakeys = qw/NewSearchName CurrentSearch SearchPrivacy Save Load/;

if ($CurrentSearch =~ /^(.*-\d+)-SavedSearch-(\d+)$/) {
    $search = RT::SavedSearch->new($session{'CurrentUser'});
    $search->Load($1, $2);
}

# Have we been asked to load a search?

if ( $ARGS{'LoadSavedSearch'} =~ /^(.*-\d+)-SavedSearch-(\d+)$/ ) {
    my $privacy = $1;
    my $search_id = $3;

    $search = RT::SavedSearch->new($session{'CurrentUser'});
    $search->Load($privacy, $search_id);
    if ($search->Id) {
        my $searchargs = $search->GetParameter('args');
	# Clean out ARGS and fill it in with the saved args from the 
	# loaded search.
	foreach my $key (@metakeys) {
	    $searchargs->{$key} = $ARGS{$key};
	}
	%ARGS = %{$searchargs};
	$CurrentSearch = "$privacy-SavedSearch-$search_id";
    } else {
        push(@results, "Error: could not load saved search "
	         . $ARGS{'LoadSavedSearch'});
    }
}

# ...or have we been asked to save a search?

if ( $ARGS{'Save'} ) {
    my %searchargs = %ARGS;
    foreach my $key (@metakeys) {
	delete $searchargs{$key};
    }

    # Is it a new search, or have we asked for a different name than the
    # current search has?  If not, just update the current search.
    if ($CurrentSearch ne 'new' 
	&& $search->Name eq $ARGS{'NewSearchName'} 
	&& $search->Privacy eq $ARGS{'SearchPrivacy'}) {
	# There is a search loaded; we just want to update it.
	$search->Save(undef, 'Article', undef, ('args' => \%searchargs));
    } else {
	# This is a new search.
	$search = RT::SavedSearch->new($session{'CurrentUser'});
	if ($ARGS{'SearchPrivacy'} =~ /^(.*)-(\d+)$/) {
	    $search->Save($ARGS{'SearchPrivacy'}, 'Article', 
			  $ARGS{'NewSearchName'}, ('args' => \%searchargs));
	    $CurrentSearch = $ARGS{'SearchPrivacy'} . "-SavedSearch-" . 
		$search->Id;
	    push(@results, "Updated search " . $search->Name);
	} else {
	    # No search privacy chosen?  Warn and default to current user.
	    # Really this should never happen.
	    push(@results, "WARNING: Saving search to user-level privacy");
	    $search->Save('RT::User-'.$session{'CurrentUser'}->Id, 'Article',
			  $ARGS{'NewSearchName'}, ('args' => \%searchargs));
	    $CurrentSearch = "RT::User-" . $session{'CurrentUser'}->Id .
		"-SavedSearch-" . $search->Id;
	    push(@results, "Created search" . $search->Name);
	}
    }
}

# }}}

# Don't want to search for a null class when there is no class specced
my $customfields = RT::CustomFields->new( $session{'CurrentUser'} );
$customfields->LimitToLookupType(RT::FM::Article->new($session{'CurrentUser'})->CustomFieldLookupType);
if ( $ARGS{'Class'} ) {
    my @Classes =
      ( ref $ARGS{'Class'} eq 'ARRAY' )
      ? @{ $ARGS{'Class'} }
      : ( $ARGS{'Class'} );
    foreach my $class (@Classes) {
        $customfields->LimitToGlobalOrObjectId($class);
    }
}
else {
    $customfields->LimitToGlobalOrObjectId();
}

my %dates;
foreach my $date qw(Created< Created> LastUpdated< LastUpdated>) {
    next unless ( $ARGS{$date} );
    my $seconds = parsedate( $ARGS{$date}, FUZZY => 1, PREFER_PAST => 1 );
    my $date_obj = RT::Date->new( $session{'CurrentUser'} );
    $date_obj->Set( Format => 'unix', Value => $seconds );
    $dates{$date} = $date_obj;

    if ( $date =~ /^(.*?)<$/i ) {
        $articles->Limit( FIELD           => $1, OPERATOR        => "<=", ENTRYAGGREGATOR => "AND", VALUE           => $date_obj->ISO );
    }

    if ( $date =~ /^(.*?)>$/i ) {
        $articles->Limit( FIELD           => $1, OPERATOR        => ">=", ENTRYAGGREGATOR => "AND", VALUE           => $date_obj->ISO );
    }

}
foreach my $link ( split ( /\s+/, $RefersTo ) ) {
    next unless ($link);
    $articles->LimitRefersTo($link);
}

foreach my $link ( split ( /\s+/, $ReferredToBy ) ) {
    next unless ($link);
    $articles->LimitReferredToBy($link);
}

if ($ARGS{'Topics'}) {
    my @Topics =
      ( ref $ARGS{'Topics'} eq 'ARRAY' )
      ? @{ $ARGS{'Topics'} }
      : ( $ARGS{'Topics'} );
    @Topics = map {split} @Topics;
    if ($ARGS{'ExpandTopics'}) {
        my %topics;
        while (@Topics) {
            my $id = shift @Topics;
            next if $topics{$id};
            my $Topics = RT::FM::TopicCollection->new($session{'CurrentUser'});
            $Topics->Limit(FIELD => 'Parent', VALUE => $id);
            push @Topics, $_->Id while $_ = $Topics->Next;
            $topics{$id}++;
        }
        @Topics = keys %topics;
        $ARGS{'Topics'} = \@Topics;
    }
    $articles->LimitTopics(@Topics);
}

my %cfs;
my $all_cfs = RT::CustomFields->new($session{'CurrentUser'});
$all_cfs->UnLimit();
while ( my $cf = $all_cfs->Next ) {
    $cfs{ $cf->Name } = $cf->Id;
}

foreach my $field ( keys %cfs ) {
   
   my @MatchLike = (ref $ARGS{ $field."~" } eq 'ARRAY' ) ? @{ $ARGS{ $field."~" } } : ( $ARGS{$field."~" } );
   my @NoMatchLike = (ref $ARGS{ $field."!~" } eq 'ARRAY' ) ? @{ $ARGS{ $field."!~" } } : ( $ARGS{$field."!~" } );

   my @Match = (ref $ARGS{ $field } eq 'ARRAY' ) ? @{ $ARGS{ $field } } : ( $ARGS{$field } );
   my @NoMatch = (ref $ARGS{ $field."!" } eq 'ARRAY' ) ? @{ $ARGS{ $field."!" } } : ( $ARGS{$field."!" } );

    foreach my $val (@MatchLike) {
        next unless $val;
        push @Match, "~".$val;
    }

    foreach my $val (@NoMatchLike) {
        next unless $val;
        push @NoMatch, "~".$val;
    }


    foreach my $value (@Match) {
        next unless $value;
        my $op;
        if ( $value =~ /^~(.*)$/ ) {
            $value = "%$1%";
            $op    = 'LIKE';
        }
        else {
            $op = '=';
        }
        $articles->LimitCustomField( FIELD           => $cfs{$field},
                                     VALUE           => $value,
                                     ENTRYAGGREGATOR => 'OR',
                                     OPERATOR        => $op );
    }
    foreach my $value (@NoMatch) {
        next unless $value;
        my $op;
        if ( $value =~ /^~(.*)$/ ) {
            $value = "%$1%";
            $op    = 'NOT LIKE';
        }
        else {
            $op = '!=';
        }
        $articles->LimitCustomField( FIELD           => $cfs{$field},
                                     VALUE           => $value,
                                     ENTRYAGGREGATOR => 'OR',
                                     OPERATOR        => $op );
    }
}


foreach my $field qw(Name Summary Class) {

   my @MatchLike = (ref $ARGS{ $field."~" } eq 'ARRAY' ) ? @{ $ARGS{ $field."~" } } : ( $ARGS{$field."~" } );
   my @NoMatchLike = (ref $ARGS{ $field."!~" } eq 'ARRAY' ) ? @{ $ARGS{ $field."!~" } } : ( $ARGS{$field."!~" } );

   my @Match = (ref $ARGS{ $field } eq 'ARRAY' ) ? @{ $ARGS{ $field } } : ( $ARGS{$field } );
   my @NoMatch = (ref $ARGS{ $field."!" } eq 'ARRAY' ) ? @{ $ARGS{ $field."!" } } : ( $ARGS{$field."!" } );

    foreach my $val (@MatchLike) {
        next unless $val;
        push @Match, "~".$val;
    }

    foreach my $val (@NoMatchLike) {
        next unless $val;
        push @NoMatch, "~".$val;
    }

    my $op;
    foreach my $value (@Match) {
        if ( $value =~ /^~(.*)$/ ) {
            $value = "%$1%";
            $op    = 'LIKE';
        }
        else {
            $op = '=';
        }

        # preprocess Classes, so we can search on class
        if ( $field eq 'Class' && $value ) {
            my $class = RT::FM::Class->new($RT::SystemUser);
            $class->Load($value);
            $value = $class->Id;
        }

        # now that we've pruned the value, get out if it's different.
        next unless $value;

        $articles->Limit( SUBCLAUSE       => $field . 'Match',
                          FIELD           => $field,
                          OPERATOR        => $op,
                          VALUE            => $value,
                          ENTRYAGGREGATOR => 'OR' );

    }
    foreach my $value (@NoMatch) {

        # preprocess Classes, so we can search on class
        if ( $value =~ /^~(.*)/ ) {
            $value = "%$1%";
            $op    = 'NOT LIKE';
        }
        else {
            $op = '!=';
        }
        if ( $field eq 'Class' ) {
            my $class = RT::FM::Class->new($RT::SystemUser);
            $class->Load($value);
            $value = $class->Id;
        }

        # now that we've pruned the value, get out if it's different.
        next unless $value;

        $articles->Limit( SUBCLAUSE       => $field . 'NoMatch',
                          OPERATOR        => $op,
                          VALUE            => $value,
                          FIELD           => $field,
                          ENTRYAGGREGATOR => 'AND' );

    }
}


$m->comp('/Elements/Callback', %ARGS, _Search => $articles);

</%init>


</%init>
<%ARGS>
$CreatedBefore => ''
$CreatedAfter => ''
$LastUpdatedBefore => ''
$LastUpdatedAfter => ''
$RefersTo => undef
$ReferredToBy => undef
$CurrentSearch => 'new'
</%ARGS>
